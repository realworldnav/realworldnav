# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bIcxOpR5_OkEheGxSPK29_MHX8XhFT5N
"""

# ============================================================================
# SETUP CELL - Run this first to install dependencies
# ============================================================================
!pip install web3 pandas eth-utils

# ============================================================================
# IMPORTS AND CONFIGURATION
# ============================================================================
from web3 import Web3
from decimal import Decimal, getcontext
from datetime import datetime, timezone
import pandas as pd
from typing import List, Dict, Optional, Tuple
from eth_utils import to_checksum_address
import time
import logging
from functools import lru_cache
import requests

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Set decimal precision
getcontext().prec = 50

# ============================================================================
# CONFIGURATION
# ============================================================================

# Your Infura API Key
INFURA_URL = "https://mainnet.infura.io/v3/16f12641c1db46beb60e95cf4c88cbe1"

# Etherscan API for additional data
ETHERSCAN_API_KEY = "P13CVTCP43NWU9GX5D9VBA2QMUTJDDS941"
ETHERSCAN_BASE_URL = "https://api.etherscan.io/api"

# Comprehensive event signatures
TOPIC0_HASH_MAP = {
    # Standard ERC20 events
    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": "Transfer",
    "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": "Approval",

    # WETH events
    "0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c": "Deposit",
    "0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65": "Withdrawal",

    # Uniswap V2 events
    "0xd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d822": "Swap",
    "0x1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1": "Sync",
    "0x4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f": "Mint",
    "0xdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d81936496": "Burn",

    # Uniswap V3 events
    "0xc42079f94a6350d7e6235f29174924f928cc2ac818eb64fed8004e115fbcca67": "SwapV3",
    "0x7a53080ba414158be7ec69b987b5fb7d07dee101bfd9eb75431776ba12931536": "Collect",
    "0x3067048beee31b25b2f1681f88dac838c8bba36af25bfb2b7cf7473a5847e35f": "IncreaseLiquidity",
    "0x26f6a048ee9138f2c0ce266f322cb99228e8d619ae2bff30c67f8dcf9d2377b4": "DecreaseLiquidity",

    # NFT events
    "0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62": "TransferSingle",
    "0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb": "TransferBatch",

    # Common DeFi events
    "0x2717ead6b9200dd235aad468c9809ea400fe33ac69b5bfaa6d3e90fc922b6398": "WithdrawDeFi",
    "0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15": "DepositDeFi",
    "0xdbe9101c0b08215e988c0bba2c9a67b15a3939bec1cdb7b40c9f25e3b6c35b00": "Stake",
    "0x31a20996dfad77ae3ee5ce9e7e3edc2ee86cdb84f58a9c19f3c0a1d0b1ffa9cb": "Unstake",

    # Blur marketplace events
    "0x94307d291f9fd23b00e69a71eb8b0d9b20c2d18c5b3adcbd5b74d5df2ad0b09a": "OrdersMatched",
    "0xd3d9500b2fb2db7c9a3e6e88b5b9e8ed5c7b39eeed3e9b3ddc2c2b28d3da7b": "OrderFulfilled",

    # Additional marketplace/DEX events
    "0xc4109843e0b7d514e4c093114b863f8e7d8d9a458c372cd51bfe526b588006c9": "OrderCancelled",
    "0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d": "BidMatched",
}

# Known tokens
VERIFIED_TOKENS = {
    "USDC": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    "DAI": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    "WETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    "WSTETH": "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
    "WBTC": "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    # Blur ecosystem
    "BLUR": "0x5283D291DBCF85356A21bA090E6db59121208b44",
    "BLUR_POOL": "0x0000000000A39bb272e79075ade125fd351887Ac",
}

TOKEN_DECIMALS = {
    "ETH": 18, "WETH": 18, "USDC": 6, "USDT": 6,
    "DAI": 18, "WBTC": 8, "WSTETH": 18, "BLUR": 18, "BLUR_POOL": 18
}

# Chainlink ETH/USD Price Feed
CHAINLINK_ETH_USD_FEED = "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"
CHAINLINK_ABI = [{
    "inputs": [],
    "name": "latestRoundData",
    "outputs": [
        {"internalType": "uint80", "name": "roundId", "type": "uint80"},
        {"internalType": "int256", "name": "answer", "type": "int256"},
        {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
        {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
        {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"},
    ],
    "stateMutability": "view",
    "type": "function",
}]

# Query settings - More conservative
INITIAL_CHUNK_SIZE = 50   # Start even smaller
MIN_CHUNK_SIZE = 10
MAX_RETRIES = 3

# ============================================================================
# OPTIMIZED INFURA BLOCKCHAIN SERVICE
# ============================================================================

class OptimizedInfuraService:
    """Optimized service without problematic broad searches"""

    def __init__(self, infura_url: str = INFURA_URL):
        print(f"🔗 Connecting to Infura...")
        self.w3 = Web3(Web3.HTTPProvider(infura_url))

        if not self.w3.is_connected():
            raise ConnectionError("Failed to connect to Ethereum node")

        print(f"✅ Connected! Chain ID: {self.w3.eth.chain_id}")
        print(f"📦 Latest block: {self.w3.eth.block_number}")

        # Initialize price feed
        self.price_feed = self.w3.eth.contract(
            address=to_checksum_address(CHAINLINK_ETH_USD_FEED),
            abi=CHAINLINK_ABI
        )

        # Statistics
        self.stats = {
            'total_logs': 0,
            'chunks_processed': 0,
            'chunks_split': 0,
            'events_found': {},
            'tokens_found': set(),
            'parse_errors': 0,
            'strategy_results': {'strategy1': 0, 'strategy2': 0, 'strategy3': 0}
        }

    @lru_cache(maxsize=100)
    def get_block_by_timestamp(self, timestamp: int) -> int:
        """Binary search for block by timestamp"""
        low = 0
        high = self.w3.eth.block_number

        while low <= high:
            mid = (low + high) // 2
            block = self.w3.eth.get_block(mid)

            if block.timestamp <= timestamp:
                low = mid + 1
            else:
                high = mid - 1

        return high

    @lru_cache(maxsize=500)
    def get_eth_price_at_block(self, block_number: int) -> Tuple[Decimal, datetime]:
        """Get ETH price and block time"""
        try:
            round_data = self.price_feed.functions.latestRoundData().call(
                block_identifier=block_number
            )
            price = Decimal(round_data[1]) / Decimal(10**8)
            block = self.w3.eth.get_block(block_number)
            block_time = datetime.fromtimestamp(block.timestamp, tz=timezone.utc)
            return price, block_time
        except:
            return Decimal("3200"), datetime.now(timezone.utc)

    @lru_cache(maxsize=300)
    def get_token_info(self, address: str) -> Tuple[str, str, int]:
        """Get token symbol, name, and decimals"""
        try:
            address_checksum = to_checksum_address(address)

            # Check known tokens first
            for symbol, addr in VERIFIED_TOKENS.items():
                if to_checksum_address(addr) == address_checksum:
                    decimals = TOKEN_DECIMALS.get(symbol, 18)
                    return symbol, symbol, decimals

            # Query contract for symbol and decimals
            erc20_abi = [
                {
                    "constant": True,
                    "inputs": [],
                    "name": "symbol",
                    "outputs": [{"name": "", "type": "string"}],
                    "type": "function"
                },
                {
                    "constant": True,
                    "inputs": [],
                    "name": "name",
                    "outputs": [{"name": "", "type": "string"}],
                    "type": "function"
                },
                {
                    "constant": True,
                    "inputs": [],
                    "name": "decimals",
                    "outputs": [{"name": "", "type": "uint8"}],
                    "type": "function"
                }
            ]

            contract = self.w3.eth.contract(address=address_checksum, abi=erc20_abi)

            try:
                symbol = contract.functions.symbol().call()
            except:
                symbol = f"TOKEN_{address[:6]}"

            try:
                name = contract.functions.name().call()
            except:
                name = symbol

            try:
                decimals = contract.functions.decimals().call()
            except:
                decimals = 18

            return symbol, name, decimals

        except Exception as e:
            return f"TOKEN_{address[:6]}", f"Unknown Token", 18

    def get_native_eth_transactions(self, wallet: str, start_block: int, end_block: int) -> List[Dict]:
        """Get native ETH transactions from Etherscan"""
        transactions = []

        try:
            print(f"   💰 Fetching native ETH transfers from Etherscan...")

            params = {
                'module': 'account',
                'action': 'txlist',
                'address': wallet,
                'startblock': start_block,
                'endblock': end_block,
                'sort': 'asc',
                'apikey': ETHERSCAN_API_KEY
            }

            response = requests.get(ETHERSCAN_BASE_URL, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data['status'] == '1' and data.get('result'):
                    for tx in data['result']:
                        if int(tx.get('value', 0)) > 0:
                            value_eth = Decimal(tx['value']) / Decimal(10**18)
                            direction = "OUT" if tx['from'].lower() == wallet.lower() else "IN"

                            try:
                                eth_price, _ = self.get_eth_price_at_block(int(tx['blockNumber']))
                            except:
                                eth_price = Decimal("3200")

                            transactions.append({
                                'timestamp': datetime.fromtimestamp(int(tx['timeStamp']), tz=timezone.utc),
                                'block_number': int(tx['blockNumber']),
                                'tx_hash': tx['hash'],
                                'event_type': 'ETH_Transfer',
                                'direction': direction,
                                'wallet': wallet,
                                'from_address': to_checksum_address(tx['from']),
                                'to_address': to_checksum_address(tx['to']) if tx['to'] else None,
                                'token_symbol': 'ETH',
                                'token_name': 'Ethereum',
                                'token_address': 'NATIVE',
                                'token_amount': float(value_eth),
                                'token_value_usd': float(value_eth * eth_price),
                                'eth_price_usd': float(eth_price),
                                'gas_used': int(tx.get('gasUsed', 0)),
                                'gas_price': int(tx.get('gasPrice', 0)),
                                'log_index': -1
                            })

                    print(f"      ✅ Found {len(transactions)} native ETH transfers")
        except Exception as e:
            print(f"      ⚠️ Error fetching native ETH transfers: {e}")

        return transactions

    def decode_log_enhanced(self, log, wallet: str) -> Optional[Dict]:
        """Enhanced log decoding with better error handling"""
        try:
            # Get event type with proper string comparison
            topic0 = log['topics'][0].hex() if log['topics'] else None

            # Ensure topic0 is lowercase for comparison
            if topic0:
                topic0 = topic0.lower()

            event_type = None
            for known_topic, event_name in TOPIC0_HASH_MAP.items():
                if topic0 == known_topic.lower():
                    event_type = event_name
                    break

            if not event_type:
                event_type = f"Unknown_{topic0[:10] if topic0 else 'None'}"

            # Track event types
            self.stats['events_found'][event_type] = self.stats['events_found'].get(event_type, 0) + 1

            # Extract addresses from topics with better error handling
            from_addr = None
            to_addr = None

            try:
                if len(log['topics']) > 1 and log['topics'][1]:
                    topic1_hex = log['topics'][1].hex()
                    from_addr = '0x' + topic1_hex[-40:]
                    from_addr = to_checksum_address(from_addr)
            except:
                pass

            try:
                if len(log['topics']) > 2 and log['topics'][2]:
                    topic2_hex = log['topics'][2].hex()
                    to_addr = '0x' + topic2_hex[-40:]
                    to_addr = to_checksum_address(to_addr)
            except:
                pass

            # Determine direction relative to our wallet
            wallet_checksum = to_checksum_address(wallet)
            direction = None

            if from_addr == wallet_checksum:
                direction = "OUT"
            elif to_addr == wallet_checksum:
                direction = "IN"
            else:
                # For events where wallet isn't in topics, check transaction sender
                try:
                    tx = self.w3.eth.get_transaction(log['transactionHash'])
                    if tx['from'] == wallet_checksum:
                        direction = "INITIATED"
                    else:
                        return None  # Wallet not involved
                except:
                    return None

            if not direction:
                return None

            # Enhanced value extraction from data field
            value = 0
            if log['data'] and log['data'] != '0x':
                try:
                    data_hex = log['data'].hex() if isinstance(log['data'], bytes) else log['data']

                    # Remove '0x' prefix if present
                    if data_hex.startswith('0x'):
                        data_hex = data_hex[2:]

                    # For most ERC20 transfers, value is the first 32 bytes (64 hex chars)
                    if len(data_hex) >= 64:
                        value_hex = data_hex[:64]
                        value = int(value_hex, 16)
                    elif len(data_hex) > 0:
                        # Try to parse whatever data we have
                        value = int(data_hex, 16)

                except Exception as e:
                    # If value parsing fails, log it but continue
                    self.stats['parse_errors'] += 1
                    value = 0

            # Get enhanced token info
            token_address = log['address']
            token_symbol, token_name, token_decimals = self.get_token_info(token_address)

            self.stats['tokens_found'].add(token_symbol)

            # Calculate token amount with proper decimals
            if value > 0:
                token_amount = Decimal(value) / Decimal(10**token_decimals)
            else:
                token_amount = Decimal(0)

            # Get price and time
            eth_price, block_time = self.get_eth_price_at_block(log['blockNumber'])

            # Calculate USD value
            if token_symbol in ["USDC", "USDT", "DAI"]:
                token_value_usd = float(token_amount)
            else:
                token_value_usd = float(token_amount * eth_price)

            return {
                'timestamp': block_time,
                'block_number': log['blockNumber'],
                'tx_hash': log['transactionHash'].hex(),
                'event_type': event_type,
                'direction': direction,
                'wallet': wallet_checksum,
                'from_address': from_addr,
                'to_address': to_addr,
                'token_symbol': token_symbol,
                'token_name': token_name,
                'token_address': token_address,
                'token_amount': float(token_amount),
                'token_value_usd': token_value_usd,
                'eth_price_usd': float(eth_price),
                'log_index': log['logIndex'],
                'gas_used': 0,  # Would need separate query
                'gas_price': 0  # Would need separate query
            }

        except Exception as e:
            self.stats['parse_errors'] += 1
            return None

    def fetch_logs_optimized(self, wallet: str, start_block: int, end_block: int) -> List:
        """Optimized log fetching with only working strategies"""
        wallet_checksum = to_checksum_address(wallet)
        wallet_topic = '0x' + wallet[2:].lower().zfill(64)
        all_logs = []

        chunk_size = INITIAL_CHUNK_SIZE
        current_start = start_block

        print(f"   📜 Optimized log fetching (wallet-specific only)...")

        while current_start <= end_block:
            current_end = min(current_start + chunk_size - 1, end_block)

            try:
                print(f"      📊 Blocks {current_start}-{current_end} (chunk: {chunk_size})")

                # Strategy 1: Wallet in topic1 (sender) - This works well
                try:
                    logs_from = self.w3.eth.get_logs({
                        'fromBlock': current_start,
                        'toBlock': current_end,
                        'topics': [None, wallet_topic]
                    })
                    all_logs.extend(logs_from)
                    self.stats['strategy_results']['strategy1'] += len(logs_from)
                    if logs_from:
                        print(f"         Strategy 1: {len(logs_from)} logs (wallet as sender)")
                except Exception as e:
                    if "query returned more than 10000 results" in str(e):
                        raise e  # Re-raise to trigger chunk splitting
                    print(f"         Strategy 1 warning: {e}")

                # Strategy 2: Wallet in topic2 (receiver) - This works well
                try:
                    logs_to = self.w3.eth.get_logs({
                        'fromBlock': current_start,
                        'toBlock': current_end,
                        'topics': [None, None, wallet_topic]
                    })
                    all_logs.extend(logs_to)
                    self.stats['strategy_results']['strategy2'] += len(logs_to)
                    if logs_to:
                        print(f"         Strategy 2: {len(logs_to)} logs (wallet as receiver)")
                except Exception as e:
                    if "query returned more than 10000 results" in str(e):
                        raise e  # Re-raise to trigger chunk splitting
                    print(f"         Strategy 2 warning: {e}")

                # Strategy 3: Specific event signatures with wallet filtering
                # Only query for the most common events to avoid overload
                common_events = [
                    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",  # Transfer
                    "0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c",  # Deposit
                    "0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65",  # Withdrawal
                ]

                for event_sig in common_events:
                    try:
                        # Query for specific event with wallet involvement
                        event_logs = self.w3.eth.get_logs({
                            'fromBlock': current_start,
                            'toBlock': current_end,
                            'topics': [event_sig, wallet_topic]  # Specific event, wallet as sender
                        })

                        event_logs2 = self.w3.eth.get_logs({
                            'fromBlock': current_start,
                            'toBlock': current_end,
                            'topics': [event_sig, None, wallet_topic]  # Specific event, wallet as receiver
                        })

                        combined_event_logs = event_logs + event_logs2
                        all_logs.extend(combined_event_logs)
                        self.stats['strategy_results']['strategy3'] += len(combined_event_logs)

                        if combined_event_logs:
                            event_name = TOPIC0_HASH_MAP.get(event_sig, "Unknown")
                            print(f"         Strategy 3: {len(combined_event_logs)} {event_name} logs")

                    except Exception as e:
                        # Don't let individual event queries fail the whole chunk
                        continue

                self.stats['chunks_processed'] += 1
                current_start = current_end + 1

                # Small delay
                time.sleep(0.05)

            except Exception as e:
                if "query returned more than 10000 results" in str(e):
                    if chunk_size <= MIN_CHUNK_SIZE:
                        print(f"         ⚠️ Chunk too small, skipping {current_start}-{current_end}")
                        current_start = current_end + 1
                        continue

                    chunk_size = max(chunk_size // 2, MIN_CHUNK_SIZE)
                    print(f"         📊 Splitting chunk to size {chunk_size}")
                    self.stats['chunks_split'] += 1
                    # Don't advance current_start, retry with smaller chunk

                elif "rate limit" in str(e).lower():
                    print(f"         ⏱️ Rate limited, waiting...")
                    time.sleep(2)
                    # Don't advance current_start, retry

                else:
                    print(f"         ❌ Error: {e}")
                    current_start = current_end + 1

        return all_logs

    def fetch_wallet_transactions(self, wallet: str, start_block: int, end_block: int) -> List[Dict]:
        """Main method to fetch all wallet transactions"""
        print(f"\n🔍 Optimized transaction fetch for {wallet}")
        print(f"   📊 Block range: {start_block} to {end_block} ({end_block - start_block + 1} blocks)")

        all_transactions = []

        # Method 1: Get native ETH transfers from Etherscan
        eth_txs = self.get_native_eth_transactions(wallet, start_block, end_block)
        all_transactions.extend(eth_txs)

        # Method 2: Optimized log fetching from Infura
        print(f"   📜 Fetching logs from Infura...")
        all_logs = self.fetch_logs_optimized(wallet, start_block, end_block)

        self.stats['total_logs'] = len(all_logs)
        print(f"   📊 Total raw logs: {len(all_logs)}")

        # Deduplicate logs
        seen = set()
        unique_logs = []
        for log in all_logs:
            log_id = (log['transactionHash'].hex(), log['logIndex'])
            if log_id not in seen:
                seen.add(log_id)
                unique_logs.append(log)

        print(f"   📊 Unique logs: {len(unique_logs)}")

        # Decode logs
        print(f"   🔄 Decoding logs...")
        for log in unique_logs:
            tx = self.decode_log_enhanced(log, wallet)
            if tx:
                all_transactions.append(tx)

        # Remove duplicates from all transactions (ETH + token)
        seen_tx = set()
        final_transactions = []
        for tx in all_transactions:
            tx_id = (tx['tx_hash'], tx.get('log_index', 0))
            if tx_id not in seen_tx:
                seen_tx.add(tx_id)
                final_transactions.append(tx)

        print(f"   ✅ Final transactions: {len(final_transactions)}")

        # Show summary
        if self.stats['events_found']:
            print(f"   📊 Event types:")
            for event_type, count in sorted(self.stats['events_found'].items(), key=lambda x: x[1], reverse=True)[:10]:
                print(f"      - {event_type}: {count}")

        if self.stats['tokens_found']:
            tokens_list = sorted(self.stats['tokens_found'])
            print(f"   💎 Tokens: {', '.join(tokens_list[:10])}")
            if len(tokens_list) > 10:
                print(f"      ... and {len(tokens_list) - 10} more")

        print(f"   📈 Strategy results: S1={self.stats['strategy_results']['strategy1']} S2={self.stats['strategy_results']['strategy2']} S3={self.stats['strategy_results']['strategy3']}")
        print(f"   📈 Stats: {self.stats['chunks_processed']} chunks, {self.stats['chunks_split']} splits, {self.stats['parse_errors']} parse errors")

        return final_transactions

# ============================================================================
# MAIN FUNCTIONS
# ============================================================================

def fetch_transactions_for_period(
    wallets: List[str],
    start_date: datetime,
    end_date: datetime
) -> pd.DataFrame:
    """Main function to fetch transactions"""

    service = OptimizedInfuraService()

    # Get block range
    print(f"📅 Finding blocks for date range...")
    start_block = service.get_block_by_timestamp(int(start_date.timestamp()))
    end_block = service.get_block_by_timestamp(int(end_date.timestamp()))
    print(f"📊 Block range: {start_block} to {end_block} ({end_block - start_block + 1} blocks)")

    # Fetch for each wallet
    all_transactions = []

    for i, wallet in enumerate(wallets):
        print(f"\n{'='*60}")
        print(f"Processing wallet {i+1}/{len(wallets)}: {wallet}")
        print(f"{'='*60}")

        wallet_txs = service.fetch_wallet_transactions(wallet, start_block, end_block)
        all_transactions.extend(wallet_txs)

    print(f"\n{'='*60}")
    print(f"📊 FINAL RESULTS")
    print(f"{'='*60}")
    print(f"Total transactions found: {len(all_transactions)}")

    # Convert to DataFrame
    if all_transactions:
        df = pd.DataFrame(all_transactions)
        df = df.sort_values('timestamp')
        # Final deduplication
        df = df.drop_duplicates(subset=['tx_hash', 'log_index'], keep='first')
        print(f"After final deduplication: {len(df)} transactions")
        return df

    return pd.DataFrame()

def analyze_transactions(df: pd.DataFrame):
    """Enhanced analysis"""
    if df.empty:
        print("\n⚠️ No transactions found!")
        return

    print(f"\n{'='*60}")
    print(f"📊 DETAILED TRANSACTION ANALYSIS")
    print(f"{'='*60}")

    # Basic stats
    print(f"\n📈 Summary:")
    print(f"   Total transactions: {len(df)}")
    print(f"   Date range: {df['timestamp'].min().date()} to {df['timestamp'].max().date()}")
    print(f"   Unique tokens: {df['token_symbol'].nunique()}")
    print(f"   Unique event types: {df['event_type'].nunique()}")

    # Event types with counts
    print(f"\n🎯 Event Types:")
    event_counts = df['event_type'].value_counts()
    for event_type, count in event_counts.items():
        print(f"   {event_type}: {count}")

    # Top tokens by transaction count
    print(f"\n💰 Top Tokens by Transaction Count:")
    token_counts = df['token_symbol'].value_counts().head(15)
    for token, count in token_counts.items():
        print(f"   {token}: {count}")

    # Direction analysis
    print(f"\n🔄 Transaction Directions:")
    direction_counts = df['direction'].value_counts()
    for direction, count in direction_counts.items():
        print(f"   {direction}: {count}")

    # Value analysis (non-zero amounts)
    non_zero = df[df['token_amount'] > 0]
    if not non_zero.empty:
        print(f"\n💵 Value Analysis (non-zero amounts only):")
        print(f"   Transactions with value: {len(non_zero)}/{len(df)}")
        if 'token_value_usd' in non_zero.columns:
            print(f"   Total USD value: ${non_zero['token_value_usd'].sum():.2f}")

            # Top value transactions
            print(f"\n💰 Top Transactions by Value:")
            top_value = non_zero.nlargest(5, 'token_value_usd')[['timestamp', 'event_type', 'direction', 'token_symbol', 'token_amount', 'token_value_usd']]
            for _, tx in top_value.iterrows():
                print(f"   {tx['timestamp'].date()} - {tx['event_type']} {tx['direction']} {tx['token_amount']:.4f} {tx['token_symbol']} (${tx['token_value_usd']:.2f})")

    # Recent transactions
    print(f"\n📝 Most Recent Transactions:")
    recent = df.nlargest(10, 'timestamp')[['timestamp', 'event_type', 'direction', 'token_symbol', 'token_amount']]
    for _, tx in recent.iterrows():
        print(f"   {tx['timestamp'].strftime('%m-%d %H:%M')} - {tx['event_type']} {tx['direction']} {tx['token_amount']:.4f} {tx['token_symbol']}")

    # Sample transaction links for verification
    print(f"\n🔗 Sample transactions for Etherscan verification:")
    for i, tx_hash in enumerate(df['tx_hash'].head(5)):
        print(f"   {i+1}. https://etherscan.io/tx/{tx_hash}")

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Run the optimized transaction grabber"""

    # CONFIGURE HERE
    WALLET_ADDRESSES = [
        "0x09C098e2283375B4E6Bc04990FDa2b1a7473F390",
    ]

    START_DATE = datetime(2024, 7, 1, tzinfo=timezone.utc)
    END_DATE = datetime(2024, 7, 31, tzinfo=timezone.utc)

    print("🚀 Blockchain Transaction Grabber V6 (Rate Limit Fixed)")
    print(f"📍 Analyzing {len(WALLET_ADDRESSES)} wallet(s)")
    print(f"📅 Period: {START_DATE.date()} to {END_DATE.date()}")

    # Fetch transactions
    df = fetch_transactions_for_period(WALLET_ADDRESSES, START_DATE, END_DATE)

    # Analyze
    analyze_transactions(df)

    # Save
    if not df.empty:
        filename = f"transactions_v6_{START_DATE.date()}_{END_DATE.date()}.csv"
        df.to_csv(filename, index=False)
        print(f"\n💾 Saved {len(df)} transactions to {filename}")

        print(f"\n📋 Available DataFrame columns:")
        print(f"   {', '.join(df.columns.tolist())}")

    return df

if __name__ == "__main__":
    df_result = main()

    if not df_result.empty:
        print(f"\n✅ SUCCESS! Found {len(df_result)} total transactions")
        print("DataFrame 'df_result' is ready for analysis")

        # Show a quick sample
        print(f"\n📊 Quick sample of results:")
        sample_cols = ['timestamp', 'event_type', 'direction', 'token_symbol', 'token_amount']
        available_cols = [col for col in sample_cols if col in df_result.columns]
        print(df_result[available_cols].head().to_string())

    else:
        print(f"\n❌ No transactions found - please verify wallet address and date range")

import requests
import json
import time

# --- Configuration ---
# Your Alchemy API key and wallet address
ALCHEMY_API_KEY = "mmhv6R8fVVR6JnSoHSHD3KRsAWxuTPJV"
WALLET_ADDRESS = "0x09C098e2283375B4E6Bc04990FDa2b1a7473F390"

# Approximate block numbers for a specific date range (e.g., July 1-31, 2024)
start_block_int = 20086180
end_block_int = 20296000

# --- API URL ---
ALCHEMY_URL = f"https://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_API_KEY}"

# --- Function to Fetch All Transfers ---
def get_all_asset_transfers(wallet_address, start_block, end_block, is_inbound=False):
    all_transfers = []
    page_key = None

    while True:
        params = {
            "fromBlock": hex(start_block),
            "toBlock": hex(end_block),
            "category": ["external", "internal", "erc20", "erc721", "erc1155"],
            "withMetadata": True,
            "excludeZeroValue": False,
            "order": "asc"
        }

        # Determine whether to use 'fromAddress' or 'toAddress'
        if is_inbound:
            params["toAddress"] = wallet_address
        else:
            params["fromAddress"] = wallet_address

        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "alchemy_getAssetTransfers",
            "params": [params]
        }

        if page_key:
            payload["params"][0]["pageKey"] = page_key

        headers = {"Content-Type": "application/json"}

        try:
            response = requests.post(ALCHEMY_URL, data=json.dumps(payload), headers=headers)
            response.raise_for_status()
            data = response.json()

            if "error" in data:
                print(f"Alchemy API Error: {data['error']['message']}")
                return []

            result = data["result"]
            transfers = result["transfers"]
            all_transfers.extend(transfers)

            print(f"Fetched {len(transfers)} transfers on this page.")

            page_key = result.get("pageKey")
            if not page_key:
                break

            time.sleep(1)

        except requests.exceptions.RequestException as e:
            print(f"An error occurred: {e}")
            break

    return all_transfers

# --- Main Execution ---
if __name__ == "__main__":
    print(f"Fetching transactions for wallet: {WALLET_ADDRESS}...")

    outbound_transactions = get_all_asset_transfers(WALLET_ADDRESS, start_block_int, end_block_int, is_inbound=False)
    inbound_transactions = get_all_asset_transfers(WALLET_ADDRESS, start_block_int, end_block_int, is_inbound=True)

    # Combine and de-duplicate transactions by hash
    all_transactions_dict = {tx["hash"]: tx for tx in outbound_transactions}
    for tx in inbound_transactions:
        all_transactions_dict[tx["hash"]] = tx

    final_transactions = list(all_transactions_dict.values())

    print(f"\n--- Summary for {WALLET_ADDRESS} ---")
    print(f"Total Transactions: {len(final_transactions)}")

    with open("wallet_transactions.json", "w") as f:
        json.dump(final_transactions, f, indent=4)

    print("\nTransaction data saved to 'wallet_transactions.json'")



"""#Fetch Units and ETH Values for Token Transfers"""

from web3 import Web3
from decimal import Decimal, getcontext
from datetime import datetime, timezone
import pandas as pd
from typing import List, Dict, Optional, Tuple
from eth_utils import to_checksum_address
import time
import logging
from functools import lru_cache
import requests

def get_block_timestamp(w3: Web3, block_number: int) -> int:
    block = w3.eth.get_block(block_number)
    return block['timestamp']

def safe_get_token_eth_price(row):
    if row["token_symbol"].upper() == "ETH":
        return Decimal("1.0")
    try:
        return get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"])
    except Exception as e:
        print(f"⚠️ Price lookup failed for {row['token_symbol']} at block {row['block_number']}: {e}")
        return None

def get_eth_usd_price_at_block(w3, block_number):
    """
    Queries Chainlink ETH/USD price at the closest round before the given block.
    """
    #from web3.middleware import geth_poa_middleware
    from web3.middleware import ExtraDataToPOAMiddleware


    # Chainlink ETH/USD AggregatorV3Interface
    aggregator_address = Web3.to_checksum_address("0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419")
    abi = [
        {
            "inputs": [],
            "name": "latestRoundData",
            "outputs": [
                {"internalType": "uint80", "name": "roundId", "type": "uint80"},
                {"internalType": "int256", "name": "answer", "type": "int256"},
                {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
                {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
                {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"}
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
            "name": "getRoundData",
            "outputs": [
                {"internalType": "uint80", "name": "roundId", "type": "uint80"},
                {"internalType": "int256", "name": "answer", "type": "int256"},
                {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
                {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
                {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"}
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    # Instantiate
    contract = w3.eth.contract(address=aggregator_address, abi=abi)

    # Binary search for round closest to the block
    latest_round = contract.functions.latestRoundData().call()[0]
    low, high = 1, latest_round
    closest_price = None

    while low <= high:
        mid = (low + high) // 2
        try:
            rd = contract.functions.getRoundData(mid).call()
            updated_at = rd[3]
            blk = w3.eth.get_block('latest')  # Fallback in case block.timestamp is not available
            blk_ts = w3.eth.get_block(block_number)['timestamp']

            if updated_at < blk_ts:
                closest_price = rd[1]
                low = mid + 1
            else:
                high = mid - 1
        except Exception:
            high = mid - 1  # skip malformed rounds

    if closest_price:
        return Decimal(closest_price) / Decimal(1e8)
    return Decimal("0")

from threading import Lock

# Constants
ERC20_FALLBACK_ABI = [
    {"name": "symbol", "outputs": [{"type": "string"}], "inputs": [], "stateMutability": "view", "type": "function"},
    {"name": "decimals", "outputs": [{"type": "uint8"}], "inputs": [], "stateMutability": "view", "type": "function"},
]

ERC20_TRANSFER_SIG = Web3.keccak(text="Transfer(address,address,uint256)").hex()
ERC1155_SINGLE_SIG = Web3.keccak(text="TransferSingle(address,address,address,uint256,uint256)").hex()
ERC1155_BATCH_SIG  = Web3.keccak(text="TransferBatch(address,address,address,uint256[],uint256[])").hex()


abi_cache = {}
abi_write_lock = Lock()

def load_abi(token_symbol, token_address=None):
    """
    Load ABI from local JSON or download from Etherscan using address.
    Falls back to ERC20 ABI if nothing is found.
    """
    cache_key = f"{token_symbol.lower()}::{token_address}"
    if cache_key in abi_cache:
        return abi_cache[cache_key]

    path = ABI_DIR / f"{token_symbol.lower()}.json"
    if path.exists():
        try:
            with open(path) as f:
                data = json.load(f)
                abi = data["abi"] if isinstance(data, dict) and "abi" in data else data
                abi_cache[cache_key] = abi
                return abi
        except Exception as e:
            print(f"❌ Error loading local ABI for {token_symbol}: {e}")

    if token_address:
        print(f"🌐 Downloading ABI for {token_symbol} from Etherscan...")
        url = (
            f"https://api.etherscan.io/api"
            f"?module=contract&action=getabi"
            f"&address={token_address}"
            f"&apikey={ETHERSCAN_API_KEY}"
        )
        try:
            resp = requests.get(url).json()
            if resp["status"] == "1":
                abi = json.loads(resp["result"])
                abi_cache[cache_key] = abi
                with abi_write_lock:
                    with open(path, "w") as f:
                        json.dump({"abi": abi}, f, indent=2)
                return abi
            else:
                print(f"❌ Failed to fetch ABI for {token_symbol}: {resp.get('result')}")
        except Exception as e:
            print(f"❌ Error fetching ABI for {token_symbol}: {e}")

    print(f"⚠️ No ABI for {token_symbol} ({token_address}), using fallback.")
    abi_cache[cache_key] = ERC20_FALLBACK_ABI
    return ERC20_FALLBACK_ABI

def parse_transfer_addresses(log):
    from_address = "0x" + log["topics"][1].hex()[-40:]
    to_address   = "0x" + log["topics"][2].hex()[-40:]
    return Web3.to_checksum_address(from_address), Web3.to_checksum_address(to_address)

# Web3 provider
INFURA_API_KEY = "02321aab179b4085b84cda11f9bffb8a"
w3 = Web3(Web3.HTTPProvider(f"https://mainnet.infura.io/v3/{INFURA_API_KEY}"))

# Feed Registry
FEED_REGISTRY_ADDRESS = "0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf"
ETH_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"

# ERC-20 Token Addresses
ERC20_ADDRESS_MAP = {
    "USDC": "0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    "DAI":  "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    "WBTC": "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    "LINK": "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    "AAVE": "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DdAe9",
    "UNI":  "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    "MATIC": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    "CRV":  "0xD533a949740bb3306d119CC777fa900bA034cd52",
    "MKR":  "0x9f8F72aA9304c8B593d555F12ef6589cC3A579A2",
    "COMP": "0xc00e94Cb662C3520282E6f5717214004A7f26888",
    "SNX":  "0xC011A72400E58ecD99Ee497CF89E3775d4bd732F",
    "LDO":  "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32",
    "AETHWETH": "0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04",
}

# ABIs
FEED_REGISTRY_ABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "base", "type": "address"},
            {"internalType": "address", "name": "quote", "type": "address"}
        ],
        "name": "getFeed",
        "outputs": [{"internalType": "contract AggregatorV2V3Interface", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
    }
]

CHAINLINK_AGGREGATOR_ABI = [
    {
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
        "name": "getRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"},
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "latestRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

# Global price cache
CHAINLINK_PRICE_CACHE = {}

@lru_cache(maxsize=None)
def get_chainlink_aggregator_info(w3, token_address: str, quote_address: str = ETH_ADDRESS):
    registry = w3.eth.contract(address=Web3.to_checksum_address(FEED_REGISTRY_ADDRESS), abi=FEED_REGISTRY_ABI)
    try:
        agg_addr = registry.functions.getFeed(
            Web3.to_checksum_address(token_address),
            Web3.to_checksum_address(quote_address)
        ).call()
        contract = w3.eth.contract(address=agg_addr, abi=CHAINLINK_AGGREGATOR_ABI)
        decimals = contract.functions.decimals().call()
        return agg_addr, decimals
    except Exception as e:
        print(f"⚠️ Chainlink feed error for {token_address}: {e}")
        return None, None

def get_chainlink_price_at_block(w3, symbol: str, block_number: int) -> Decimal:
    symbol = symbol.upper()
    key = (symbol, block_number)
    if key in CHAINLINK_PRICE_CACHE:
        return CHAINLINK_PRICE_CACHE[key]

    token_address = ERC20_ADDRESS_MAP.get(symbol)
    if not token_address:
        raise ValueError(f"Unsupported token symbol: {symbol}")

    agg_addr, decimals = get_chainlink_aggregator_info(w3, token_address)
    if not agg_addr:
        return Decimal("0")

    contract = w3.eth.contract(address=agg_addr, abi=CHAINLINK_AGGREGATOR_ABI)

    try:
        target_ts = w3.eth.get_block(block_number)["timestamp"]
    except:
        return Decimal("0")

    latest_round = contract.functions.latestRoundData().call()[0]
    low, high = 1, latest_round
    closest_price = None

    while low <= high:
        mid = (low + high) // 2
        try:
            rd = contract.functions.getRoundData(mid).call()
            updated_at = rd[3]
            answer = rd[1]
            if updated_at <= target_ts:
                closest_price = Decimal(answer) / Decimal(10**decimals)
                low = mid + 1
            else:
                high = mid - 1
        except:
            high = mid - 1

    if closest_price is not None:
        CHAINLINK_PRICE_CACHE[key] = closest_price
        return closest_price

    return Decimal("0")

TOKEN_PRICE_ALIASES = {
    "AETHWETH": "WETH",
    "AWETH": "WETH",
    "AETH": "ETH",  # if applicable
    "STETH": "ETH",  # for Lido staked ETH
    # Add more aTokens or wrappers as needed
}

STABLECOINS = {"USDC", "USDT", "DAI"}

def get_token_eth_price_at_block(w3, token_symbol, block_number):
    """
    Return token/ETH price at given block.
    Includes fallback alias handling (e.g., AETHWETH → WETH).
    """
    token_symbol = TOKEN_PRICE_ALIASES.get(token_symbol.upper(), token_symbol.upper())

    if token_symbol == "ETH" or token_symbol == "WETH":
        return Decimal("1.0")

    if token_symbol in STABLECOINS:
        eth_usd = get_chainlink_price_at_block(w3, "ETH", block_number)
        return Decimal("1.0") / eth_usd if eth_usd else Decimal("0")

    return get_chainlink_price_at_block(w3, token_symbol, block_number)


def detect_eth_unwraps_from_internal_trace(w3, tx_hash, known_weth_contract="0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"):
    try:
        trace = w3.manager.request_blocking(
            "debug_traceTransaction",
            [tx_hash, {"tracer": "callTracer"}]
        )
        unwraps = []
        def recurse(c):
            if (
                c.get("type") == "CALL" and
                c.get("from", "").lower() == known_weth_contract.lower() and
                Decimal(c.get("value", "0")) > 0
            ):
                unwraps.append({
                    "from": c["from"],
                    "to": c["to"],
                    "eth_value": Web3.from_wei(int(c["value"]), "ether")
                })
            for sub in c.get("calls", []):
                recurse(sub)

        recurse(trace)
        return unwraps
    except Exception as e:
        print(f"⚠️ Failed to trace {tx_hash}: {e}")
        return []

MAX_WORKERS = 10  # Tune based on your node/provider's capacity

WRAPPED_ETH_EQUIVALENTS = {
    "WETH", "AETHWETH", "AWETH", "AETH", "AETHWETHV2", "AETHV2", "AETHWETHV3", "AETHV3"
}

WETH_GATEWAYS = {
    "0xDcD33426BA191383f1c9B431A342498fdac73488",  # Aave V2 WETH Gateway
    "0x2Fdaeba0f67cB5Cbc06Af0E718cF6f0F85c779B0"   # Aave V3 example
}

from decimal import Decimal, InvalidOperation

def safe_decimal_from_wei_string(val):
    try:
        return Decimal(int(val))  # handles hex strings like '0xabc' too
    except (ValueError, TypeError):
        return Decimal(0)

def process_single_tx(tx_hash, w3, token_metadata_cache):
    records = []
    try:
        tx_hash_str = tx_hash if isinstance(tx_hash, str) else tx_hash.hex()
        tx = w3.eth.get_transaction(tx_hash)
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        block = w3.eth.get_block(tx.blockNumber)

        # 🟢 Native ETH transfer
        if tx["value"] > 0:
            try:
                eth_amt = Web3.from_wei(tx["value"], "ether")
                price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                usd_val = eth_amt * price

                records.append({
                    "hash": tx_hash_str,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block["timestamp"],
                    "token_symbol": "ETH",
                    "token_address": None,
                    "token_decimals": 18,
                    "token_amount": Decimal(str(eth_amt)),
                    "raw_value": tx["value"],
                    "from": tx["from"],
                    "to": tx["to"],
                    "transfer_type": "eth",
                    "token_eth_price": Decimal("1.0"),
                    "eth_value": Decimal(str(eth_amt)),
                    "usd_value": usd_val
                })
            except Exception as e:
                print(f"⚠️ Unwrap trace parse error in tx {tx_hash_str}: {e}")

        for log in receipt.logs:
            sig = log["topics"][0].hex()

            # 🟡 ERC-20 Transfer
            if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                try:
                    token_address = Web3.to_checksum_address(log["address"])
                    from_addr, to_addr = parse_transfer_addresses(log)
                    raw_value = int.from_bytes(log["data"], byteorder='big')
                    if raw_value == 0:
                        continue
                except:
                    continue

                if token_address in token_metadata_cache:
                    metadata = token_metadata_cache[token_address]
                    abi = load_abi(metadata["symbol"], token_address=token_address)
                else:
                    try:
                        temp_contract = w3.eth.contract(address=token_address, abi=ERC20_FALLBACK_ABI)
                        symbol = temp_contract.functions.symbol().call()
                        decimals = temp_contract.functions.decimals().call()
                        metadata = {"symbol": symbol, "decimals": decimals}
                        token_metadata_cache[token_address] = metadata
                        abi = load_abi(symbol, token_address=token_address)
                    except:
                        continue

                token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": metadata["symbol"],
                    "token_address": token_address,
                    "token_decimals": metadata["decimals"],
                    "token_amount": token_amount,
                    "raw_value": raw_value,
                    "from": from_addr,
                    "to": to_addr,
                    "transfer_type": "erc20"
                })

            # 🔵 ERC-721 Transfer
            elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                from_addr = "0x" + log["topics"][1].hex()[-40:]
                to_addr   = "0x" + log["topics"][2].hex()[-40:]
                token_id  = int(log["topics"][3].hex(), 16)

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC721",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(1),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc721"
                })

            # 🟣 ERC-1155 TransferSingle
            elif sig == ERC1155_SINGLE_SIG:
                try:
                    from_addr = "0x" + log["topics"][2].hex()[-40:]
                    to_addr   = "0x" + log["topics"][3].hex()[-40:]
                    token_id, quantity = decode(["uint256", "uint256"], log["data"])
                except:
                    continue

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC1155",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(quantity),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc1155"
                })

        # 🔍 Detect unwraps using internal traces
        try:
            for attempt in range(3):
                try:
                    trace = w3.provider.make_request("debug_traceTransaction", [tx_hash_str])
                    break
                except Exception as e:
                    if hasattr(e, 'response') and getattr(e.response, 'status_code', None) == 429:
                        wait = 2 ** attempt
                        print(f"🔁 Rate limited. Retrying in {wait}s...")
                        time.sleep(wait)
                    else:
                        raise
            else:
                trace = None
            call_trace = w3.provider.make_request("trace_transaction", [tx_hash_str])
            for entry in call_trace.get("result", []):
                action = entry.get("action", {})
                value_raw = action.get("value", "0")

                try:
                    # Safely convert hex or decimal string to integer
                    value = int(value_raw, 0)  # auto-handles '123' and '0xabc'
                except Exception as e:
                    print(f"⚠️ Invalid value format in trace: {value_raw} ({type(value_raw)}): {e}")
                    continue

                if entry.get("type") == "call" and value > 0:
                    from_addr = Web3.to_checksum_address(action.get("from"))
                    to_addr = Web3.to_checksum_address(action.get("to"))

                    try:
                        if from_addr in WETH_GATEWAYS:
                            eth_amt = Decimal(value) / Decimal(10**18)
                            price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                            usd_val = eth_amt * price

                            records.append({
                                "hash": tx_hash,
                                "block_number": tx.blockNumber,
                                "block_timestamp": block["timestamp"],
                                "token_symbol": "ETH",
                                "token_address": None,
                                "token_decimals": 18,
                                "token_amount": eth_amt,
                                "raw_value": value,
                                "from": from_addr,
                                "to": to_addr,
                                "transfer_type": "unwrap",
                                "token_eth_price": Decimal("1.0"),
                                "eth_value": eth_amt,
                                "usd_value": usd_val
                            })
                    except Exception as e:
                        print(f"⚠️ Error processing unwrap from {from_addr}: {e}")

            #for entry in call_trace.get("result", []):
             #   action = entry.get("action", {})
              #  if entry.get("type") == "call" and Decimal(action.get("value", "0")) > 0:
               #     from_addr = Web3.to_checksum_address(action.get("from"))
                #    to_addr = Web3.to_checksum_address(action.get("to"))
                 #   try:
                  #      value = int(action.get("value"))
                   #     if from_addr in WETH_GATEWAYS:
                    #        eth_amt = Decimal(value) / Decimal(10**18)
                     #       price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                      #      usd_val = eth_amt * price
#
 #                           records.append({
  #                              "hash": tx_hash,
   #                             "block_number": tx.blockNumber,
    #                            "block_timestamp": block["timestamp"],
     #                           "token_symbol": "ETH",
      #                          "token_address": None,
       #                         "token_decimals": 18,
        #                        "token_amount": eth_amt,
         #                       "raw_value": value,
          #                      "from": from_addr,
           #                     "to": to_addr,
            #                    "transfer_type": "unwrap",
             #                   "token_eth_price": Decimal("1.0"),
              #                  "eth_value": eth_amt,
               #                 "usd_value": usd_val
                #            })
                 #   except (ValueError, InvalidOperation) as e:
                  #      print(f"⚠️ Invalid decimal conversion for unwrap value: {action.get('value')} - {e}")

        except Exception as e:
            print(f"⚠️ Trace failed for unwrap on {tx_hash_str}: {e}")

    except Exception as e:
        print(f"⚠️ Failed on tx {tx_hash}: {e}")
    return records
def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    all_records = []
    token_metadata_cache = {}

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(process_single_tx, tx_hash, w3, token_metadata_cache): tx_hash
            for tx_hash in df_hashes["hash"].unique()
        }

        for future in tqdm(as_completed(futures), total=len(futures), desc="Processing tx hashes"):
            result = future.result()
            if result:
                all_records.extend(result)

    if not all_records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(all_records)

    # ── Pricing logic ─────────────────────────────────────────────────────────
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(safe_get_token_eth_price, axis=1)
        #df_token["token_eth_price"] = df_token.progress_apply(
         #   lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
          #  axis=1
        #)
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    df_priceable = pd.concat([
        df_token,
        df[df["transfer_type"].isin(["native", "eth", "unwrap"])]
    ], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final

# ── Example usage ────────────────────────────────────────────────────────────

#df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'][:100].unique()}) #df_for_token_transfers_AETHWETH #df_for_token_transfers
df_hashes = pd.DataFrame({'hash':["0xba3d0e40e37ba06d1cd005c634d039f31a18ea019a60f192fe96e328f5016a6b"]})
df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "transfer_type", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head(20)

df_enriched["unwrap_detected"] = (
    #(df_enriched["transfer_type"] == "eth") &
    (df_enriched["from"].str.lower() == "0xc02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".lower()) &
    (df_enriched["token_symbol"] == "ETH")
)
df_enriched

"""##Sandbox - Old Code"""

#IGNORE / DO NOT RUN THIS CELL

from web3 import Web3
from decimal import Decimal
import pandas as pd

# Global cache dictionary: {(symbol, block_number): price}
CHAINLINK_TOKEN_ETH_FEEDS = {
    "USDC": "0x986b5E1e1755e3C2440e960477f25201B0a8bbD4",   # USDC/ETH
    "USDT": "0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46",   # USDT/ETH
    "DAI":  "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9",   # DAI/ETH
    "WBTC": "0xdeb288f737066589598e9214e782fa5a8ed689e8",   # WBTC/ETH
    "LINK": "0xDC530D9457755926550b59e8ECcdaE7624181557",   # LINK/ETH
    "AAVE": "0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012",   # AAVE/ETH
    "UNI":  "0x553303d460EE0afB37EdFf9bE42922D8FF63220e",   # UNI/ETH
    "MATIC": "0x327e23A4855b6F663a28c5161541d69Af8973302",  # MATIC/ETH
    "CRV":  "0xCd627aA160A6fa45eb793d19Ef54f5062F20f33f",   # CRV/ETH
    "MKR":  "0x24551a8Fb2A7211A25a17B1481f043A8a8adC7f2",   # MKR/ETH
    "COMP": "0x1B39Ee86Ec5979ba5C322b826B3Ec7Ac9043CfcB",   # COMP/ETH
    "SNX":  "0xE96C4407597CD507002dF88ff6E0008AB41266Ee",   # SNX/ETH
    "LDO":  "0x4e844125952D32AcdF339BE976c98E22F6F318dB",   # LDO/ETH
}

CHAINLINK_PRICE_CACHE = {}

def get_chainlink_price_at_block(w3, symbol: str, block_number: int) -> Decimal:
    """
    Fetches the USD price of a token (ETH, USDC, etc.) at a specific block using Chainlink.
    Caches prices to reduce repeated calls.
    """
    symbol = symbol.upper()
    key = (symbol, block_number)
    if key in CHAINLINK_PRICE_CACHE:
        return CHAINLINK_PRICE_CACHE[key]

    if symbol not in CHAINLINK_AGGREGATORS:
        raise ValueError(f"No Chainlink feed configured for {symbol}")

    agg_addr = CHAINLINK_AGGREGATORS[symbol]
    contract = w3.eth.contract(address=agg_addr, abi=CHAINLINK_ABI)

    # Get target timestamp for the block
    try:
        target_ts = w3.eth.get_block(block_number)["timestamp"]
    except:
        return Decimal("0")

    # Binary search for closest round <= timestamp
    latest_round = contract.functions.latestRoundData().call()[0]
    low, high = 1, latest_round
    closest_price = None

    while low <= high:
        mid = (low + high) // 2
        try:
            rd = contract.functions.getRoundData(mid).call()
            updated_at = rd[3]
            price = rd[1]

            if updated_at <= target_ts:
                closest_price = Decimal(price) / Decimal(1e8)
                low = mid + 1
            else:
                high = mid - 1
        except:
            high = mid - 1  # Skip bad rounds

    if closest_price is not None:
        CHAINLINK_PRICE_CACHE[key] = closest_price
        return closest_price

    # fallback
    return Decimal("0")

def prewarm_chainlink_cache(w3, block_numbers: list, symbols: list):
    """
    Preloads Chainlink prices for given block numbers and symbols into the global cache.
    """
    from tqdm import tqdm
    symbols = [s.upper() for s in symbols]
    print(f"🔄 Prewarming Chainlink cache for {len(symbols)} symbols × {len(block_numbers)} blocks...")

    for symbol in tqdm(symbols, desc="Symbols"):
        for blk in tqdm(block_numbers, leave=False, desc=f"{symbol} blocks"):
            try:
                get_chainlink_price_at_block(w3, symbol, blk)
            except Exception as e:
                print(f"⚠️ Failed to cache {symbol} @ block {blk}: {e}")

def get_token_eth_price_at_block(w3, token_symbol, block_number):
    """
    Return token/ETH price at given block.
    For stablecoins, price is $1 / ETH price from Chainlink.
    """
    STABLECOINS = {"USDC", "USDT", "DAI"}
    token_symbol = token_symbol.upper()

    if token_symbol == "ETH":
        return Decimal("1.0")

    if token_symbol in STABLECOINS:
        eth_usd = get_chainlink_price_at_block(w3, "ETH", block_number)
        return Decimal("1.0") / eth_usd if eth_usd else Decimal("0")

    # Optionally: fallback to 0 for unsupported tokens (or extend with Reservoir)
    return Decimal("0")


# Chainlink Aggregator ABI (minimal)
CHAINLINK_AGGREGATOR_ABI = [
    {
        "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
        "name": "getRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"},
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "latestRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

# Uniswap V3 Pool ABI (minimal)
UNISWAP_V3_POOL_ABI = [
    {
        "inputs": [{"internalType": "uint32[]", "name": "secondsAgos", "type": "uint32[]"}],
        "name": "observe",
        "outputs": [
            {"internalType": "int56[]", "name": "tickCumulatives", "type": "int56[]"},
            {"internalType": "uint160[]", "name": "secondsPerLiquidityCumulativeX128s", "type": "uint160[]"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {"name": "token0", "outputs": [{"type": "address"}], "stateMutability": "view", "type": "function"},
    {"name": "token1", "outputs": [{"type": "address"}], "stateMutability": "view", "type": "function"},
]

# Feeds and Pools
CHAINLINK_TOKEN_ETH_FEEDS = {
    "USDC": "0x986b5E1e1755e3C2440e960477f25201B0a8bbD4",
    "DAI":  "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9",
    "LINK": "0xb4c4a493AB6356497713A78FFA6c60FB53517c63",
    # Add more
}

UNISWAP_TOKEN_ETH_POOLS = {
    "USDC": "0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640",  # USDC/WETH 0.05%
    "DAI":  "0xC2e9f25be6257c210d7adf0d4cd6e3e881ba25f8",
    "LINK": "0xa2107fa78b2519cbb58c1c3b5f275fe6f45e55dd",
}

from decimal import Decimal

# Replace with actual address for mainnet Chainlink ETH/USD feed
CHAINLINK_ETH_USD_FEED = "0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419"  # Mainnet ETH/USD

STABLECOIN_SYMBOLS = {"USDC", "USDT"}  # Add "DAI" etc. if desired

WRAPPED_ETH_EQUIVALENTS = {
    "WETH", "AETHWETH", "AWETH", "AETH", "AETHWETHV2", "AETHV2", "AETHWETHV3", "AETHV3"
    }

def get_token_eth_price_at_block(w3, token_symbol, block_number):
    symbol = token_symbol.upper()

    # ✅ 1 WETH = 1 ETH
    # 🔁 Treat wrapped ETH variants as 1:1
    if symbol in WRAPPED_ETH_EQUIVALENTS:
        return Decimal("1")
    #if symbol == "WETH":
      #return Decimal("1")

    # ✅ $1 stablecoin fallback: USDC, USDT, etc.
    if symbol in STABLECOIN_SYMBOLS:
        eth_usd_price = get_eth_usd_price_at_block(w3, block_number)
        if eth_usd_price and eth_usd_price > 0:
            return Decimal("1") / Decimal(eth_usd_price)

    ts = get_block_timestamp(w3, block_number)

    # ✅ Chainlink price feed
    if symbol in CHAINLINK_TOKEN_ETH_FEEDS:
        try:
            aggregator = w3.eth.contract(
                address=Web3.to_checksum_address(CHAINLINK_TOKEN_ETH_FEEDS[symbol]),
                abi=CHAINLINK_AGGREGATOR_ABI
            )
            price = get_closest_chainlink_price(w3, aggregator, ts)
            if price:
                return price
        except Exception as e:
            print(f"[Chainlink fallback] {symbol}: {e}")

    # ✅ Uniswap TWAP fallback
    if symbol in UNISWAP_TOKEN_ETH_POOLS:
        try:
            return get_uniswap_twap_token_eth_price(w3, UNISWAP_TOKEN_ETH_POOLS[symbol])
        except Exception as e:
            print(f"[Uniswap fallback] {symbol}: {e}")

    raise ValueError(f"No price source for {token_symbol}")


def get_eth_usd_price_at_block(w3, block_number):
    """Fetch ETH/USD price from Chainlink at a specific block timestamp."""
    ts = get_block_timestamp(w3, block_number)

    aggregator = w3.eth.contract(
        address=Web3.to_checksum_address(CHAINLINK_ETH_USD_FEED),
        abi=CHAINLINK_AGGREGATOR_ABI
    )
    price = get_closest_chainlink_price(w3, aggregator, ts)
    if price:
        return Decimal(price)
    else:
        raise ValueError(f"No ETH/USD price found at block {block_number}")

def get_eth_usd_price_at_block(w3, block_number):
    """
    Queries Chainlink ETH/USD price at the closest round before the given block.
    """
    from web3.middleware import geth_poa_middleware


    # Chainlink ETH/USD AggregatorV3Interface
    aggregator_address = Web3.to_checksum_address("0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419")
    abi = [
        {
            "inputs": [],
            "name": "latestRoundData",
            "outputs": [
                {"internalType": "uint80", "name": "roundId", "type": "uint80"},
                {"internalType": "int256", "name": "answer", "type": "int256"},
                {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
                {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
                {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"}
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
            "name": "getRoundData",
            "outputs": [
                {"internalType": "uint80", "name": "roundId", "type": "uint80"},
                {"internalType": "int256", "name": "answer", "type": "int256"},
                {"internalType": "uint256", "name": "startedAt", "type": "uint256"},
                {"internalType": "uint256", "name": "updatedAt", "type": "uint256"},
                {"internalType": "uint80", "name": "answeredInRound", "type": "uint80"}
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    # Instantiate
    contract = w3.eth.contract(address=aggregator_address, abi=abi)

    # Binary search for round closest to the block
    latest_round = contract.functions.latestRoundData().call()[0]
    low, high = 1, latest_round
    closest_price = None

    while low <= high:
        mid = (low + high) // 2
        try:
            rd = contract.functions.getRoundData(mid).call()
            updated_at = rd[3]
            blk = w3.eth.get_block('latest')  # Fallback in case block.timestamp is not available
            blk_ts = w3.eth.get_block(block_number)['timestamp']

            if updated_at < blk_ts:
                closest_price = rd[1]
                low = mid + 1
            else:
                high = mid - 1
        except Exception:
            high = mid - 1  # skip malformed rounds

    if closest_price:
        return Decimal(closest_price) / Decimal(1e8)
    return Decimal("0")

from concurrent.futures import ThreadPoolExecutor, as_completed
from eth_abi import decode
from decimal import Decimal, InvalidOperation
from tqdm import tqdm
import pandas as pd
from web3 import Web3
import time

MAX_WORKERS = 10  # Tune based on your node/provider's capacity

WRAPPED_ETH_EQUIVALENTS = {
    "WETH", "AETHWETH", "AWETH", "AETH", "AETHWETHV2", "AETHV2", "AETHWETHV3", "AETHV3"
}

WETH_GATEWAYS = {
    "0xDcD33426BA191383f1c9B431A342498fdac73488",  # Aave V2 WETH Gateway
    "0x2Fdaeba0f67cB5Cbc06Af0E718cF6f0F85c779B0"   # Aave V3 example
}

def process_single_tx(tx_hash, w3, token_metadata_cache):
    records = []
    try:
        tx_hash_str = tx_hash if isinstance(tx_hash, str) else tx_hash.hex()
        tx = w3.eth.get_transaction(tx_hash)
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        block = w3.eth.get_block(tx.blockNumber)

        # 🟢 Native ETH transfer
        if tx["value"] > 0:
            try:
                eth_amt = Web3.from_wei(tx["value"], "ether")
                price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                usd_val = eth_amt * price

                records.append({
                    "hash": tx_hash_str,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block["timestamp"],
                    "token_symbol": "ETH",
                    "token_address": None,
                    "token_decimals": 18,
                    "token_amount": Decimal(str(eth_amt)),
                    "raw_value": tx["value"],
                    "from": tx["from"],
                    "to": tx["to"],
                    "transfer_type": "eth",
                    "token_eth_price": Decimal("1.0"),
                    "eth_value": Decimal(str(eth_amt)),
                    "usd_value": usd_val
                })
            except Exception as e:
                print(f"⚠️ Unwrap trace parse error in tx {tx_hash_str}: {e}")

        for log in receipt.logs:
            sig = log["topics"][0].hex()

            # 🟡 ERC-20 Transfer
            if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                try:
                    token_address = Web3.to_checksum_address(log["address"])
                    from_addr, to_addr = parse_transfer_addresses(log)
                    raw_value = int.from_bytes(log["data"], byteorder='big')
                    if raw_value == 0:
                        continue
                except:
                    continue

                if token_address in token_metadata_cache:
                    metadata = token_metadata_cache[token_address]
                    abi = load_abi(metadata["symbol"], token_address=token_address)
                else:
                    try:
                        temp_contract = w3.eth.contract(address=token_address, abi=ERC20_FALLBACK_ABI)
                        symbol = temp_contract.functions.symbol().call()
                        decimals = temp_contract.functions.decimals().call()
                        metadata = {"symbol": symbol, "decimals": decimals}
                        token_metadata_cache[token_address] = metadata
                        abi = load_abi(symbol, token_address=token_address)
                    except:
                        continue

                token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": metadata["symbol"],
                    "token_address": token_address,
                    "token_decimals": metadata["decimals"],
                    "token_amount": token_amount,
                    "raw_value": raw_value,
                    "from": from_addr,
                    "to": to_addr,
                    "transfer_type": "erc20"
                })

            # 🔵 ERC-721 Transfer
            elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                from_addr = "0x" + log["topics"][1].hex()[-40:]
                to_addr   = "0x" + log["topics"][2].hex()[-40:]
                token_id  = int(log["topics"][3].hex(), 16)

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC721",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(1),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc721"
                })

            # 🟣 ERC-1155 TransferSingle
            elif sig == ERC1155_SINGLE_SIG:
                try:
                    from_addr = "0x" + log["topics"][2].hex()[-40:]
                    to_addr   = "0x" + log["topics"][3].hex()[-40:]
                    token_id, quantity = decode(["uint256", "uint256"], log["data"])
                except:
                    continue

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC1155",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(quantity),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc1155"
                })

        # 🔍 Detect unwraps using internal traces
        try:
            for attempt in range(3):
                try:
                    trace = w3.provider.make_request("debug_traceTransaction", [tx_hash_str])
                    break
                except Exception as e:
                    if hasattr(e, 'response') and getattr(e.response, 'status_code', None) == 429:
                        wait = 2 ** attempt
                        print(f"🔁 Rate limited. Retrying in {wait}s...")
                        time.sleep(wait)
                    else:
                        raise
            else:
                trace = None

            call_trace = w3.provider.make_request("trace_transaction", [tx_hash_str])
            for entry in call_trace.get("result", []):
                action = entry.get("action", {})
                if entry.get("type") == "call" and Decimal(action.get("value", "0")) > 0:
                    from_addr = Web3.to_checksum_address(action.get("from"))
                    to_addr = Web3.to_checksum_address(action.get("to"))
                    try:
                        value = int(action.get("value"))
                        if from_addr in WETH_GATEWAYS:
                            eth_amt = Decimal(value) / Decimal(10**18)
                            price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                            usd_val = eth_amt * price

                            records.append({
                                "hash": tx_hash,
                                "block_number": tx.blockNumber,
                                "block_timestamp": block["timestamp"],
                                "token_symbol": "ETH",
                                "token_address": None,
                                "token_decimals": 18,
                                "token_amount": eth_amt,
                                "raw_value": value,
                                "from": from_addr,
                                "to": to_addr,
                                "transfer_type": "unwrap",
                                "token_eth_price": Decimal("1.0"),
                                "eth_value": eth_amt,
                                "usd_value": usd_val
                            })
                    except (ValueError, InvalidOperation) as e:
                        print(f"⚠️ Invalid decimal conversion for unwrap value: {action.get('value')} - {e}")

        except Exception as e:
            print(f"⚠️ Trace failed for unwrap on {tx_hash_str}: {e}")

    except Exception as e:
        print(f"⚠️ Failed on tx {tx_hash}: {e}")
    return records

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    all_records = []
    token_metadata_cache = {}

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(process_single_tx, tx_hash, w3, token_metadata_cache): tx_hash
            for tx_hash in df_hashes["hash"].unique()
        }

        for future in tqdm(as_completed(futures), total=len(futures), desc="Processing tx hashes"):
            result = future.result()
            if result:
                all_records.extend(result)

    if not all_records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(all_records)

    # ── Pricing logic ─────────────────────────────────────────────────────────
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(
            lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
            axis=1
        )
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    df_priceable = pd.concat([
        df_token,
        df[df["transfer_type"].isin(["native", "eth", "unwrap"])]
    ], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final

# ── Example usage ────────────────────────────────────────────────────────────

df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'][:100].unique()}) #df_for_token_transfers_AETHWETH #df_for_token_transfers
#df_hashes = pd.DataFrame({'hash':["0xf398634f42e8959345574e4a278e71c86df2b767bc2dbdbf79c6e153accc7e52"]})
df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "transfer_type", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head(20)

from concurrent.futures import ThreadPoolExecutor, as_completed
from eth_abi import decode
from decimal import Decimal
from tqdm import tqdm
import pandas as pd
from web3 import Web3


MAX_WORKERS = 10  # Tune based on your node/provider's capacity

WRAPPED_ETH_EQUIVALENTS = {
    "WETH", "AETHWETH", "AWETH", "AETH", "AETHWETHV2", "AETHV2", "AETHWETHV3", "AETHV3"
}

WETH_GATEWAYS = {
    "0xDcD33426BA191383f1c9B431A342498fdac73488",  # Aave V2 WETH Gateway
    "0x2Fdaeba0f67cB5Cbc06Af0E718cF6f0F85c779B0"   # Aave V3 example
}



def process_single_tx(tx_hash, w3, token_metadata_cache):
    records = []
    try:
        tx = w3.eth.get_transaction(tx_hash)
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        block = w3.eth.get_block(tx.blockNumber)

        # 🟢 Native ETH transfer
        if tx["value"] > 0:
            eth_amt = Web3.from_wei(tx["value"], "ether")
            price = get_eth_usd_price_at_block(w3, tx.blockNumber)
            usd_val = eth_amt * price

            entries.append({
                "hash": tx_hash if isinstance(tx_hash, str) else tx_hash.hex(),
                "block_number": tx.blockNumber,
                "block_timestamp": block["timestamp"],
                "token_symbol": "ETH",
                "token_address": None,
                "token_decimals": 18,
                "token_amount": eth_amt,
                "raw_value": tx["value"],
                "from": tx["from"],
                "to": tx["to"],
                "transfer_type": "eth",
                "token_eth_price": Decimal("1.0"),
                "eth_value": eth_amt,
                "usd_value": usd_val
            })
        #if tx["value"] > 0:
         #   eth_amount = Decimal(tx["value"]) / Decimal(10**18)
          #  records.append({
           #     "hash": tx_hash,
            #    "block_number": tx.blockNumber,
             #   "block_timestamp": block.timestamp,
              #  "token_symbol": "ETH",
               # "token_address": None,
           #     "token_decimals": 18,
            #    "token_amount": eth_amount,
             #   "raw_value": tx["value"],
              #  "from": tx["from"],
               # "to": tx["to"],
                #"transfer_type": "native"
            #})

        for log in receipt.logs:
            sig = log["topics"][0].hex()

            # 🟡 ERC-20 Transfer
            if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                try:
                    token_address = Web3.to_checksum_address(log["address"])
                    from_addr, to_addr = parse_transfer_addresses(log)
                    raw_value = int.from_bytes(log["data"], byteorder='big')
                    if raw_value == 0:
                        continue
                except:
                    continue

                if token_address in token_metadata_cache:
                    metadata = token_metadata_cache[token_address]
                    abi = load_abi(metadata["symbol"], token_address=token_address)
                else:
                    try:
                        temp_contract = w3.eth.contract(address=token_address, abi=ERC20_FALLBACK_ABI)
                        symbol = temp_contract.functions.symbol().call()
                        decimals = temp_contract.functions.decimals().call()
                        metadata = {"symbol": symbol, "decimals": decimals}
                        token_metadata_cache[token_address] = metadata
                        abi = load_abi(symbol, token_address=token_address)
                    except:
                        continue

                token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": metadata["symbol"],
                    "token_address": token_address,
                    "token_decimals": metadata["decimals"],
                    "token_amount": token_amount,
                    "raw_value": raw_value,
                    "from": from_addr,
                    "to": to_addr,
                    "transfer_type": "erc20"
                })

            # 🔵 ERC-721 Transfer
            elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                from_addr = "0x" + log["topics"][1].hex()[-40:]
                to_addr   = "0x" + log["topics"][2].hex()[-40:]
                token_id  = int(log["topics"][3].hex(), 16)

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC721",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(1),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc721"
                })

            # 🟣 ERC-1155 TransferSingle
            elif sig == ERC1155_SINGLE_SIG:
                try:
                    from_addr = "0x" + log["topics"][2].hex()[-40:]
                    to_addr   = "0x" + log["topics"][3].hex()[-40:]
                    token_id, quantity = decode(["uint256", "uint256"], log["data"])
                except:
                    continue

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC1155",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(quantity),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc1155"
                })
        # 🔍 Detect unwraps using internal traces (via Infura-compatible debug_traceTransaction)
        try:
            trace = w3.provider.make_request("debug_traceTransaction", [tx_hash.hex() if hasattr(tx_hash, "hex") else tx_hash])
            calls = trace.get("result", {}).get("structLogs", [])
            # Infura omits structLogs unless tracing is fully supported — fallback to callTrace if available
            if not calls:
                call_trace = w3.provider.make_request("trace_transaction", [tx_hash.hex() if hasattr(tx_hash, "hex") else tx_hash])
                for entry in call_trace.get("result", []):
                    action = entry.get("action", {})
                    if entry.get("type") == "call" and Decimal(action.get("value", "0")) > 0:
                        from_addr = Web3.to_checksum_address(action.get("from"))
                        to_addr = Web3.to_checksum_address(action.get("to"))
                        value = int(action.get("value"))

                        # Check if coming from a known gateway or contract that holds WETH
                        if from_addr in WETH_GATEWAYS:
                            eth_amt = Decimal(value) / Decimal(10**18)
                            price = get_eth_usd_price_at_block(w3, tx.blockNumber)
                            usd_val = eth_amt * price

                            records.append({
                                "hash": tx_hash,
                                "block_number": tx.blockNumber,
                                "block_timestamp": block["timestamp"],
                                "token_symbol": "ETH",
                                "token_address": None,
                                "token_decimals": 18,
                                "token_amount": eth_amt,
                                "raw_value": value,
                                "from": from_addr,
                                "to": to_addr,
                                "transfer_type": "unwrap",
                                "token_eth_price": Decimal("1.0"),
                                "eth_value": eth_amt,
                                "usd_value": usd_val
                            })
        except Exception as e:
            print(f"⚠️ Trace failed for unwrap on {tx_hash}: {e}")

    except Exception as e:
        print(f"⚠️ Failed on tx {tx_hash}: {e}")
    return records



def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    all_records = []
    token_metadata_cache = {}

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(process_single_tx, tx_hash, w3, token_metadata_cache): tx_hash
            for tx_hash in df_hashes["hash"].unique()
        }

        for future in tqdm(as_completed(futures), total=len(futures), desc="Processing tx hashes"):
            result = future.result()
            if result:
                all_records.extend(result)

    if not all_records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(all_records)


    # ── Pricing logic ─────────────────────────────────────────────────────────
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(
            lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
            axis=1
        )
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    df_priceable = pd.concat([
        df_token,
        df[df["transfer_type"].isin(["native", "eth", "unwrap"])]
    ], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final


# ── Example usage ────────────────────────────────────────────────────────────
df_hashes = pd.DataFrame({'hash': df_for_token_transfers_AETHWETH['hash'][:100].unique()}) #df_for_token_transfers_AETHWETH #df_for_token_transfers
#df_hashes = pd.DataFrame({'hash':["0xf398634f42e8959345574e4a278e71c86df2b767bc2dbdbf79c6e153accc7e52"]})
df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)
print(df_enriched)
df_enriched[
    ["hash", "transfer_type", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head(20)

def get_token_eth_price_at_block(w3, token_symbol, block_number):

    if token_symbol.upper() == "ETH":
        return Decimal("1.0")

    if token_symbol.upper() in {"USDC", "USDT", "DAI"}:
        eth_usd = get_chainlink_price_at_block(w3, "ETH", block_number)
        return Decimal("1.0") / eth_usd if eth_usd > 0 else Decimal("0")

    return get_chainlink_price_at_block(w3, token_symbol.upper(), block_number)


def load_abi(token_symbol, token_address=None):
    """
    Load ABI from local JSON or download from Etherscan using address.
    Falls back to ERC20 ABI if nothing is found.
    """
    path = ABI_DIR / f"{token_symbol.lower()}.json"
    if path.exists():
        with open(path) as f:
            data = json.load(f)
            return data["abi"] if isinstance(data, dict) and "abi" in data else data

    if token_address:
        print(f"🌐 Downloading ABI for {token_symbol} from Etherscan...")
        url = (
            f"https://api.etherscan.io/api"
            f"?module=contract&action=getabi"
            f"&address={token_address}"
            f"&apikey={ETHERSCAN_API_KEY}"
        )
        try:
            resp = requests.get(url).json()
            if resp["status"] == "1":
                abi = json.loads(resp["result"])
                with open(path, "w") as f:
                    json.dump({"abi": abi}, f, indent=2)
                return abi
            else:
                print(f"❌ Failed to fetch ABI for {token_symbol}: {resp.get('result')}")
        except Exception as e:
            print(f"❌ Error fetching ABI for {token_symbol}: {e}")

    print(f"⚠️ No ABI for {token_symbol}, using fallback.")
    return ERC20_FALLBACK_ABI

def parse_transfer_addresses(log):
    from_address = "0x" + log["topics"][1].hex()[-40:]
    to_address   = "0x" + log["topics"][2].hex()[-40:]
    return Web3.to_checksum_address(from_address), Web3.to_checksum_address(to_address)

from concurrent.futures import ThreadPoolExecutor, as_completed

MAX_WORKERS = 10  # Tune based on system/network resources

def process_single_tx(tx_hash, w3, token_metadata_cache):
    records = []
    try:
        tx = w3.eth.get_transaction(tx_hash)
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        block = w3.eth.get_block(tx.blockNumber)

        # Native ETH transfer
        if tx["value"] > 0:
            eth_amount = Decimal(tx["value"]) / Decimal(10**18)
            records.append({
                "hash": tx_hash,
                "block_number": tx.blockNumber,
                "block_timestamp": block.timestamp,
                "token_symbol": "ETH",
                "token_address": None,
                "token_decimals": 18,
                "token_amount": eth_amount,
                "raw_value": tx["value"],
                "from": tx["from"],
                "to": tx["to"],
                "transfer_type": "native"
            })

        for log in receipt.logs:
            sig = log["topics"][0].hex()

            if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                try:
                    token_address = Web3.to_checksum_address(log["address"])
                    from_addr, to_addr = parse_transfer_addresses(log)
                    raw_value = int.from_bytes(log["data"], byteorder='big')
                    if raw_value == 0:
                        continue
                except:
                    continue

                if token_address in token_metadata_cache:
                    metadata = token_metadata_cache[token_address]
                    abi = load_abi(metadata["symbol"])
                else:
                    try:
                        temp_contract = w3.eth.contract(address=token_address, abi=ERC20_FALLBACK_ABI)
                        symbol = temp_contract.functions.symbol().call()
                        decimals = temp_contract.functions.decimals().call()
                        metadata = {"symbol": symbol, "decimals": decimals}
                        token_metadata_cache[token_address] = metadata
                        abi = load_abi(symbol)
                    except:
                        continue

                token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": metadata["symbol"],
                    "token_address": token_address,
                    "token_decimals": metadata["decimals"],
                    "token_amount": token_amount,
                    "raw_value": raw_value,
                    "from": from_addr,
                    "to": to_addr,
                    "transfer_type": "erc20"
                })

            elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                from_addr = "0x" + log["topics"][1].hex()[-40:]
                to_addr   = "0x" + log["topics"][2].hex()[-40:]
                token_id  = int(log["topics"][3].hex(), 16)

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC721",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(1),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc721"
                })

            elif sig == ERC1155_SINGLE_SIG:
                try:
                    from_addr = "0x" + log["topics"][2].hex()[-40:]
                    to_addr   = "0x" + log["topics"][3].hex()[-40:]
                    token_id, quantity = w3.codec.decode(["uint256", "uint256"], log["data"])
                except:
                    continue

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ERC1155",
                    "token_address": log["address"],
                    "token_decimals": None,
                    "token_amount": Decimal(quantity),
                    "raw_value": token_id,
                    "from": Web3.to_checksum_address(from_addr),
                    "to": Web3.to_checksum_address(to_addr),
                    "transfer_type": "erc1155"
                })

    except Exception as e:
        print(f"⚠️ Failed on tx {tx_hash}: {e}")
    return records

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    all_records = []
    token_metadata_cache = {}  # Shared dict

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(process_single_tx, tx_hash, w3, token_metadata_cache): tx_hash
            for tx_hash in df_hashes["hash"].unique()
        }

        for future in tqdm(as_completed(futures), total=len(futures), desc="Processing tx hashes"):
            result = future.result()
            if result:
                all_records.extend(result)

    if not all_records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(all_records)

    # ETH pricing logic for applicable rows
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(
            lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
            axis=1
        )
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    # Native ETH and ERC-20 get priced in USD
    df_priceable = df_token.copy()
    df_priceable = pd.concat([df_priceable, df[df["transfer_type"] == "native"]], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    # Combine
    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final

df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'][:10].unique()})
df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "transfer_type", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head()

def load_abi(token_symbol):
    path = ABI_DIR / f"{token_symbol.lower()}.json"
    if path.exists():
        with open(path) as f:
            data = json.load(f)
            return data["abi"] if isinstance(data, dict) and "abi" in data else data
    else:
        print(f"⚠️ No ABI for {token_symbol}, using fallback.")
        return ERC20_FALLBACK_ABI

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    token_metadata_cache = {}
    records = []

    for tx_hash in tqdm(df_hashes["hash"].unique(), desc="Processing tx hashes"):
        try:
            tx = w3.eth.get_transaction(tx_hash)
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            block = w3.eth.get_block(tx.blockNumber)

            # 🟢 Native ETH transfer
            if tx["value"] > 0:
                eth_amount = Decimal(tx["value"]) / Decimal(10**18)
                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ETH",
                    "token_address": None,
                    "token_decimals": 18,
                    "token_amount": eth_amount,
                    "raw_value": tx["value"],
                    "from": tx["from"],
                    "to": tx["to"],
                    "transfer_type": "native"
                })

            for log in receipt.logs:
                sig = log["topics"][0].hex()

                # 🟡 ERC-20 Transfer
                if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                    try:
                        token_address = Web3.to_checksum_address(log["address"])
                        from_addr, to_addr = parse_transfer_addresses(log)
                        raw_value = int.from_bytes(log["data"], byteorder='big')
                    except:
                        continue

                    if raw_value == 0:
                        continue

                    if token_address in token_metadata_cache:
                        metadata = token_metadata_cache[token_address]
                        abi = load_abi(metadata["symbol"])
                    else:
                        try:
                            fallback_abi = ERC20_FALLBACK_ABI
                            temp_contract = w3.eth.contract(address=token_address, abi=fallback_abi)
                            symbol = temp_contract.functions.symbol().call()
                            decimals = temp_contract.functions.decimals().call()
                            metadata = {"symbol": symbol, "decimals": decimals}
                            token_metadata_cache[token_address] = metadata
                            abi = load_abi(symbol)
                        except:
                            continue

                    token_contract = w3.eth.contract(address=token_address, abi=abi)
                    metadata = token_metadata_cache[token_address]

                    token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": metadata["symbol"],
                        "token_address": token_address,
                        "token_decimals": metadata["decimals"],
                        "token_amount": token_amount,
                        "raw_value": raw_value,
                        "from": from_addr,
                        "to": to_addr,
                        "transfer_type": "erc20"
                    })

                # 🔵 ERC-721 Transfer
                elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                    from_addr = "0x" + log["topics"][1].hex()[-40:]
                    to_addr   = "0x" + log["topics"][2].hex()[-40:]
                    token_id  = int(log["topics"][3].hex(), 16)

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": "ERC721",
                        "token_address": log["address"],
                        "token_decimals": None,
                        "token_amount": Decimal(1),
                        "raw_value": token_id,
                        "from": Web3.to_checksum_address(from_addr),
                        "to": Web3.to_checksum_address(to_addr),
                        "transfer_type": "erc721"
                    })

                # 🟣 ERC-1155 (TransferSingle only for now)
                elif sig == ERC1155_SINGLE_SIG:
                    try:
                        from_addr = "0x" + log["topics"][2].hex()[-40:]
                        to_addr   = "0x" + log["topics"][3].hex()[-40:]
                        data = w3.codec.decode(["uint256", "uint256"], log["data"])
                        token_id, quantity = data
                    except:
                        continue

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": "ERC1155",
                        "token_address": log["address"],
                        "token_decimals": None,
                        "token_amount": Decimal(quantity),
                        "raw_value": token_id,
                        "from": Web3.to_checksum_address(from_addr),
                        "to": Web3.to_checksum_address(to_addr),
                        "transfer_type": "erc1155"
                    })

        except Exception as e:
            print(f"⚠️ Failed on tx {tx_hash}: {e}")
            continue

    if not records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(records)

    # ETH pricing logic for applicable rows
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(
            lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
            axis=1
        )
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    # Native ETH and ERC-20 get priced in USD
    df_priceable = df_token.copy()
    df_priceable = pd.concat([df_priceable, df[df["transfer_type"] == "native"]], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    # Combine
    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final

#df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'][:10].unique()})
#df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

#df_enriched[
 #   ["hash", "transfer_type", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
#].head()

from web3 import Web3
from decimal import Decimal
import pandas as pd
from tqdm import tqdm
import json
from pathlib import Path

ABI_DIR = Path("/content/drive/MyDrive/Drip_Capital/smart_contract_ABIs")

ERC20_FALLBACK_ABI = [
    {"name": "symbol", "outputs": [{"type": "string"}], "inputs": [], "stateMutability": "view", "type": "function"},
    {"name": "decimals", "outputs": [{"type": "uint8"}], "inputs": [], "stateMutability": "view", "type": "function"},
]

ERC20_TRANSFER_SIG     = Web3.keccak(text="Transfer(address,address,uint256)").hex()
ERC1155_SINGLE_SIG     = Web3.keccak(text="TransferSingle(address,address,address,uint256,uint256)").hex()
ERC1155_BATCH_SIG      = Web3.keccak(text="TransferBatch(address,address,address,uint256[],uint256[])").hex()

def load_abi(token_symbol):
    path = ABI_DIR / f"{token_symbol.lower()}.json"
    if path.exists():
        with open(path) as f:
            data = json.load(f)
            return data["abi"] if isinstance(data, dict) and "abi" in data else data
    else:
        print(f"⚠️ No ABI for {token_symbol}, using fallback.")
        return ERC20_FALLBACK_ABI

def parse_transfer_addresses(log):
    from_address = "0x" + log["topics"][1].hex()[-40:]
    to_address   = "0x" + log["topics"][2].hex()[-40:]
    return Web3.to_checksum_address(from_address), Web3.to_checksum_address(to_address)

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    if not isinstance(df_hashes, pd.DataFrame):
        df_hashes = pd.DataFrame({'hash': df_hashes})

    token_metadata_cache = {}
    records = []

    for tx_hash in tqdm(df_hashes["hash"].unique(), desc="Processing tx hashes"):
        try:
            tx = w3.eth.get_transaction(tx_hash)
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            block = w3.eth.get_block(tx.blockNumber)

            # 🟢 Native ETH transfer
            if tx["value"] > 0:
                eth_amount = Decimal(tx["value"]) / Decimal(10**18)
                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_symbol": "ETH",
                    "token_address": None,
                    "token_decimals": 18,
                    "token_amount": eth_amount,
                    "raw_value": tx["value"],
                    "from": tx["from"],
                    "to": tx["to"],
                    "transfer_type": "native"
                })

            for log in receipt.logs:
                sig = log["topics"][0].hex()

                # 🟡 ERC-20 Transfer
                if sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 3:
                    try:
                        token_address = Web3.to_checksum_address(log["address"])
                        from_addr, to_addr = parse_transfer_addresses(log)
                        raw_value = int.from_bytes(log["data"], byteorder='big')
                    except:
                        continue

                    if raw_value == 0:
                        continue

                    if token_address in token_metadata_cache:
                        metadata = token_metadata_cache[token_address]
                        abi = load_abi(metadata["symbol"])
                    else:
                        try:
                            fallback_abi = ERC20_FALLBACK_ABI
                            temp_contract = w3.eth.contract(address=token_address, abi=fallback_abi)
                            symbol = temp_contract.functions.symbol().call()
                            decimals = temp_contract.functions.decimals().call()
                            metadata = {"symbol": symbol, "decimals": decimals}
                            token_metadata_cache[token_address] = metadata
                            abi = load_abi(symbol)
                        except:
                            continue

                    token_contract = w3.eth.contract(address=token_address, abi=abi)
                    metadata = token_metadata_cache[token_address]

                    token_amount = Decimal(raw_value) / Decimal(10**metadata["decimals"])

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": metadata["symbol"],
                        "token_address": token_address,
                        "token_decimals": metadata["decimals"],
                        "token_amount": token_amount,
                        "raw_value": raw_value,
                        "from": from_addr,
                        "to": to_addr,
                        "transfer_type": "erc20"
                    })

                # 🔵 ERC-721 Transfer
                elif sig == ERC20_TRANSFER_SIG and len(log["topics"]) == 4:
                    from_addr = "0x" + log["topics"][1].hex()[-40:]
                    to_addr   = "0x" + log["topics"][2].hex()[-40:]
                    token_id  = int(log["topics"][3].hex(), 16)

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": "ERC721",
                        "token_address": log["address"],
                        "token_decimals": None,
                        "token_amount": Decimal(1),
                        "raw_value": token_id,
                        "from": Web3.to_checksum_address(from_addr),
                        "to": Web3.to_checksum_address(to_addr),
                        "transfer_type": "erc721"
                    })

                # 🟣 ERC-1155 (TransferSingle only for now)
                elif sig == ERC1155_SINGLE_SIG:
                    try:
                        from_addr = "0x" + log["topics"][2].hex()[-40:]
                        to_addr   = "0x" + log["topics"][3].hex()[-40:]
                        data = w3.codec.decode(["uint256", "uint256"], log["data"])
                        token_id, quantity = data
                    except:
                        continue

                    records.append({
                        "hash": tx_hash,
                        "block_number": tx.blockNumber,
                        "block_timestamp": block.timestamp,
                        "token_symbol": "ERC1155",
                        "token_address": log["address"],
                        "token_decimals": None,
                        "token_amount": Decimal(quantity),
                        "raw_value": token_id,
                        "from": Web3.to_checksum_address(from_addr),
                        "to": Web3.to_checksum_address(to_addr),
                        "transfer_type": "erc1155"
                    })

        except Exception as e:
            print(f"⚠️ Failed on tx {tx_hash}: {e}")
            continue

    if not records:
        print("⚠️ No valid transfers found.")
        return pd.DataFrame()

    df = pd.DataFrame(records)

    # ETH pricing logic for applicable rows
    df["token_eth_price"] = None
    df["eth_value"] = None
    df["usd_value"] = None

    df_token = df[df["transfer_type"] == "erc20"].copy()

    if not df_token.empty:
        tqdm.pandas(desc="Getting token/ETH price")
        df_token["token_eth_price"] = df_token.progress_apply(
            lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
            axis=1
        )
        df_token["eth_value"] = df_token["token_amount"] * df_token["token_eth_price"]

    # Native ETH and ERC-20 get priced in USD
    df_priceable = df_token.copy()
    df_priceable = pd.concat([df_priceable, df[df["transfer_type"] == "native"]], ignore_index=True)

    if not df_priceable.empty:
        eth_usd = eth_usd_df_with_eod(df_priceable["hash"].unique(), w3, aggregator)
        df_priceable = df_priceable.merge(eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
        df_priceable["usd_value"] = df_priceable["eth_value"].fillna(df_priceable["token_amount"]) * df_priceable["TX_ETH_USD_price"]

    # Combine
    df_final = df.drop(columns=["token_eth_price", "eth_value", "usd_value"]).merge(
        df_priceable[["hash", "token_eth_price", "eth_value", "usd_value"]],
        on="hash", how="left"
    )

    print(f"✅ Enriched {len(df_final)} transfers")
    return df_final

from decimal import Decimal
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import pandas as pd

MAX_WORKERS = 10  # adjust as needed

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    tx_hashes = df_hashes["hash"].dropna().unique().tolist()
    all_results = []

    def process_tx(tx_hash):
        try:
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            tx      = w3.eth.get_transaction(tx_hash)
            block   = w3.eth.get_block(tx.blockNumber)
            transfers = extract_token_transfers(receipt)  # ← Your own logic
            enriched = []

            for t in transfers:
                symbol = t["token_symbol"]
                amount = Decimal(t["token_amount"])
                block_num = tx.blockNumber

                # Chainlink pricing
                token_eth_price = get_token_eth_price_at_block(w3, symbol, block_num)
                eth_value = amount * token_eth_price
                eth_usd_price = get_chainlink_price_at_block(w3, "ETH", block_num)
                usd_value = eth_value * eth_usd_price

                enriched.append({
                    **t,
                    "hash": tx_hash,
                    "block_number": block_num,
                    "eth_value": eth_value,
                    "usd_value": usd_value,
                })

            return enriched

        except Exception as e:
            print(f"⚠️ Error processing tx {tx_hash}: {e}")
            return []

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        future_to_hash = {
            executor.submit(process_tx, h): (idx + 1, h)
            for idx, h in enumerate(tx_hashes)
        }

        for future in tqdm(as_completed(future_to_hash), total=len(future_to_hash), desc="Processing tx hashes"):
            try:
                all_results.extend(future.result())
            except Exception as e:
                idx, h = future_to_hash[future]
                print(f"❌ Error in tx {idx}/{len(tx_hashes)}: {h} — {e}")

    return pd.DataFrame(all_results)

TRANSFER_EVENT_SIG = w3.keccak(text="Transfer(address,address,uint256)").hex()

def extract_token_transfers(receipt):
    transfers = []

    for log in receipt["logs"]:
        if log["topics"][0].hex() == TRANSFER_EVENT_SIG:
            try:
                from_addr = Web3.to_checksum_address("0x" + log["topics"][1].hex()[-40:])
                to_addr   = Web3.to_checksum_address("0x" + log["topics"][2].hex()[-40:])
                token_amt = int(log["data"], 16)

                contract = w3.eth.contract(address=log["address"], abi=load_abi(log["address"]))
                symbol   = contract.functions.symbol().call()
                decimals = contract.functions.decimals().call()
                amount   = Decimal(token_amt) / Decimal(10**decimals)

                transfers.append({
                    "token_address": log["address"],
                    "token_symbol": symbol,
                    "from": from_addr,
                    "to": to_addr,
                    "token_amount": amount
                })
            except Exception as e:
                print(f"⚠️ Failed to decode log: {e}")

    return transfers

from decimal import Decimal
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import pandas as pd
from web3 import Web3

MAX_WORKERS = 10
TRANSFER_EVENT_SIG = Web3.keccak(text="Transfer(address,address,uint256)").hex()
TRANSFER_BATCH_SIG = Web3.keccak(text="TransferBatch(address,address,address,uint256[],uint256[])").hex()

# Assumes load_abi, get_token_eth_price_at_block, and get_chainlink_price_at_block are already defined

def extract_token_transfers(receipt):
    transfers = []
    for log in receipt.logs:
        try:
            sig_hash = log["topics"][0].hex()
            token_address = Web3.to_checksum_address(log["address"])
            abi = load_abi(token_address)
            contract = w3.eth.contract(address=token_address, abi=abi)

            if sig_hash == TRANSFER_EVENT_SIG and len(log["topics"]) == 3:
                from_addr = Web3.to_checksum_address("0x" + log["topics"][1].hex()[-40:])
                to_addr = Web3.to_checksum_address("0x" + log["topics"][2].hex()[-40:])
                amount_raw = int(log["data"], 16)
                symbol = contract.functions.symbol().call()
                decimals = contract.functions.decimals().call()
                amount = Decimal(amount_raw) / Decimal(10 ** decimals)

                transfers.append({
                    "token_address": token_address,
                    "token_symbol": symbol,
                    "from": from_addr,
                    "to": to_addr,
                    "token_amount": amount
                })

            elif sig_hash == TRANSFER_BATCH_SIG:
                decoded = contract.events.TransferBatch().processLog(log)
                symbol = contract.functions.symbol().call()

                for tid, amt in zip(decoded["args"]["ids"], decoded["args"]["values"]):
                    transfers.append({
                        "token_address": token_address,
                        "token_symbol": f"{symbol} #{tid}",
                        "from": decoded["args"]["from"],
                        "to": decoded["args"]["to"],
                        "token_amount": Decimal(amt)
                    })
        except Exception as e:
            print(f"⚠️ Failed to decode log from {log['address']}: {e}")
    return transfers

def process_tx(tx_hash, w3):
    try:
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        tx = w3.eth.get_transaction(tx_hash)
        block_number = tx.blockNumber

        transfers = extract_token_transfers(receipt)
        enriched_rows = []

        for transfer in transfers:
            symbol = transfer["token_symbol"]
            amount = Decimal(transfer["token_amount"])

            token_eth_price = get_token_eth_price_at_block(w3, symbol, block_number)
            eth_usd_price = get_chainlink_price_at_block(w3, "ETH", block_number)

            eth_value = amount * token_eth_price
            usd_value = eth_value * eth_usd_price

            enriched_rows.append({
                **transfer,
                "hash": tx_hash,
                "block_number": block_number,
                "eth_value": eth_value,
                "usd_value": usd_value,
            })

        return enriched_rows
    except Exception as e:
        print(f"⚠️ Error processing tx {tx_hash}: {e}")
        return []

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    tx_hashes = df_hashes["hash"].dropna().unique().tolist()
    all_results = []

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        future_to_hash = {
            executor.submit(process_tx, h, w3): (idx + 1, h)
            for idx, h in enumerate(tx_hashes)
        }

        for future in tqdm(as_completed(future_to_hash), total=len(future_to_hash), desc="Processing tx hashes"):
            try:
                all_results.extend(future.result())
            except Exception as e:
                idx, h = future_to_hash[future]
                print(f"❌ Error in tx {idx}/{len(tx_hashes)}: {h} — {e}")

    return pd.DataFrame(all_results)

import requests
import json
import time
from pathlib import Path
from web3 import Web3
from decimal import Decimal

# Event selectors
TRANSFER_SIG = Web3.keccak(text="Transfer(address,address,uint256)").hex()
TRANSFER_SINGLE_SIG = Web3.keccak(text="TransferSingle(address,address,address,uint256,uint256)").hex()
TRANSFER_BATCH_SIG = Web3.keccak(text="TransferBatch(address,address,address,uint256[],uint256[])").hex()

# Settings
ETHERSCAN_API_KEY = "<your_api_key>"  # 🔁 Insert your Etherscan key here
ABI_DIR = Path("/content/drive/MyDrive/Drip_Capital/smart_contract_ABIs")
ABI_DIR.mkdir(parents=True, exist_ok=True)
abi_memory_cache = {}
RATE_LIMIT_DELAY = 0.6  # ~2/sec

# ───────────────────────────────────────────────────────────────────────

def fetch_and_save_abi(address: str):
    address = address.lower()
    url = f"https://api.etherscan.io/api?module=contract&action=getabi&address={address}&apikey={ETHERSCAN_API_KEY}"
    try:
        time.sleep(RATE_LIMIT_DELAY)
        resp = requests.get(url)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("status") == "1":
                abi = json.loads(result["result"])
                path = ABI_DIR / f"{address}.json"
                path.write_text(json.dumps(abi, indent=2))
                abi_memory_cache[address] = abi
                print(f"✅ Fetched + saved ABI: {address}")
                return abi
            else:
                print(f"❌ ABI unverified or unavailable: {address} — {result.get('message')}")
    except Exception as e:
        print(f"⚠️ ABI fetch failed for {address}: {e}")
    return None

def load_abi(address: str):
    address = address.lower()
    if address in abi_memory_cache:
        return abi_memory_cache[address]
    path = ABI_DIR / f"{address}.json"
    if path.exists():
        abi = json.loads(path.read_text())
        abi_memory_cache[address] = abi
        return abi
    return fetch_and_save_abi(address)

# ───────────────────────────────────────────────────────────────────────

def extract_token_transfers(receipt):
    transfers = []

    for log in receipt["logs"]:
        try:
            topics = log["topics"]
            addr = Web3.to_checksum_address(log["address"])
            abi = load_abi(addr)
            if abi is None:
                continue
            contract = w3.eth.contract(address=addr, abi=abi)

            # ERC-20 or ERC-721 Transfer
            if topics[0].hex() == TRANSFER_SIG:
                from_addr = Web3.to_checksum_address("0x" + topics[1].hex()[-40:])
                to_addr = Web3.to_checksum_address("0x" + topics[2].hex()[-40:])
                amount = int(log["data"], 16)
                token_id = None

                try:
                    symbol = contract.functions.symbol().call()
                    decimals = contract.functions.decimals().call()
                    token_amt = Decimal(amount) / Decimal(10**decimals)
                except:
                    # fallback for ERC-721
                    symbol = "ERC-721"
                    token_amt = Decimal(1)
                    try:
                        token_id = int(topics[3].hex(), 16)
                    except:
                        pass

                transfers.append({
                    "token_address": addr,
                    "token_symbol": symbol,
                    "from": from_addr,
                    "to": to_addr,
                    "token_amount": token_amt,
                    "token_id": token_id,
                })

            # ERC-1155: TransferSingle
            elif topics[0].hex() == TRANSFER_SINGLE_SIG:
                decoded = contract.events.TransferSingle().processLog(log)
                transfers.append({
                    "token_address": addr,
                    "token_symbol": "ERC-1155",
                    "from": decoded["args"]["from"],
                    "to": decoded["args"]["to"],
                    "token_amount": Decimal(decoded["args"]["value"]),
                    "token_id": int(decoded["args"]["id"]),
                })

            # ERC-1155: TransferBatch
            elif topics[0].hex() == TRANSFER_BATCH_SIG:
                decoded = contract.events.TransferBatch().processLog(log)
                for token_id, value in zip(decoded["args"]["ids"], decoded["args"]["values"]):
                    transfers.append({
                        "token_address": addr,
                        "token_symbol": "ERC-1155",
                        "from": decoded["args"]["from"],
                        "to": decoded["args"]["to"],
                        "token_amount": Decimal(value),
                        "token_id": int(token_id),
                    })

        except Exception as e:
            print(f"⚠️ Failed to decode log for {log['address']}: {e}")
            continue

    return transfers

def get_block_timestamp(w3: Web3, block_number: int) -> int:
    block = w3.eth.get_block(block_number)
    return block['timestamp']

def get_historical_price(coingecko_id: str, date_str: str):
    """Date format: DD-MM-YYYY"""
    url = f"https://api.coingecko.com/api/v3/coins/{coingecko_id}/history?date={date_str}&localization=false"
    response = requests.get(url)
    if not response.ok:
        raise Exception(f"Price fetch failed: {response.status_code}")
    data = response.json()
    price_usd = data["market_data"]["current_price"]["usd"]
    price_eth = data["market_data"]["current_price"]["eth"]
    return Decimal(str(price_usd)), Decimal(str(price_eth))

def decode_transfer_and_get_value(w3: Web3, token_symbol: str, value: int, block_number: int):
    token = TOKEN_INFO[token_symbol]
    decimals = token["decimals"]
    coingecko_id = token["coingecko_id"]

    # Step 1: Convert to human-readable units
    amount = Decimal(value) / Decimal(10 ** decimals)

    # Step 2: Get block timestamp
    timestamp = get_block_timestamp(w3, block_number)
    from datetime import datetime
    dt = datetime.utcfromtimestamp(timestamp)
    date_str = dt.strftime('%d-%m-%Y')

    # Step 3: Get historical prices
    usd_price, eth_price = get_historical_price(coingecko_id, date_str)

    return {
        "token": token_symbol,
        "amount": amount,
        "price_usd": usd_price,
        "usd_value": amount * usd_price,
        "price_eth": eth_price,
        "eth_value": amount * eth_price,
        "block_number": block_number,
        "timestamp": dt.isoformat() + "Z"
    }

from web3 import Web3
from decimal import Decimal
import pandas as pd
from tqdm import tqdm

# Constants
ERC20_TRANSFER_SIG_HASH = w3.keccak(text="Transfer(address,address,uint256)").hex()
ERC20_ABI = [
    {"name": "decimals", "outputs": [{"type": "uint8"}], "stateMutability": "view", "type": "function"},
    {"name": "symbol", "outputs": [{"type": "string"}], "stateMutability": "view", "type": "function"},
]

def parse_transfer_addresses(log):
    """Extract 'from' and 'to' from Transfer log topics"""
    from_address = "0x" + log["topics"][1].hex()[-40:]
    to_address = "0x" + log["topics"][2].hex()[-40:]
    return Web3.to_checksum_address(from_address), Web3.to_checksum_address(to_address)

def enrich_token_transfers_from_hashes(df_hashes, w3, aggregator):
    records = []
    token_metadata_cache = {}


    for tx_hash in tqdm(df_hashes["hash"].unique(), desc="Processing tx hashes"):
#for tx_hash in df_hashes["hash"].unique():
        try:
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            tx = w3.eth.get_transaction(tx_hash)
            block = w3.eth.get_block(tx.blockNumber)

            for log in receipt.logs:
                if log["topics"][0].hex() != ERC20_TRANSFER_SIG_HASH or len(log["topics"]) != 3:
                    continue

                token_address = Web3.to_checksum_address(log["address"])
                raw_value = int.from_bytes(log["data"], byteorder='big')   # ✅ safe

                #raw_value = int(log["data"], 16)
                from_addr, to_addr = parse_transfer_addresses(log)

                if token_address in token_metadata_cache:
                    metadata = token_metadata_cache[token_address]
                else:
                    token_contract = w3.eth.contract(address=token_address, abi=ERC20_ABI)
                    try:
                        symbol = token_contract.functions.symbol().call()
                        decimals = token_contract.functions.decimals().call()
                        metadata = {"symbol": symbol, "decimals": decimals}
                        token_metadata_cache[token_address] = metadata
                    except:
                        continue  # Not a valid ERC-20

                records.append({
                    "hash": tx_hash,
                    "block_number": tx.blockNumber,
                    "block_timestamp": block.timestamp,
                    "token_address": token_address,
                    "token_symbol": metadata["symbol"],
                    "token_decimals": metadata["decimals"],
                    "raw_value": raw_value,
                    "from": from_addr,
                    "to": to_addr,
                })

        except Exception as e:
            print(f"⚠️ Error processing tx {tx_hash}: {e}")

    if not records:
        return pd.DataFrame()

    df = pd.DataFrame(records)

    # Compute token amount
    df["token_amount"] = df.apply(
        lambda row: Decimal(row["raw_value"]) / Decimal(10 ** int(row["token_decimals"])),
        axis=1
    )

    # Get token/ETH price
    df["token_eth_price"] = df.apply(
        lambda row: get_token_eth_price_at_block(w3, row["token_symbol"], row["block_number"]),
        axis=1
    )

    df["eth_value"] = df["token_amount"] * df["token_eth_price"]

    # Get ETH/USD price from your aggregator
    df_eth_usd = eth_usd_df_with_eod(df["hash"].unique(), w3, aggregator)
    df_eth_usd = df_eth_usd.drop_duplicates(subset="hash")

    df = df.merge(df_eth_usd[["hash", "TX_ETH_USD_price"]], on="hash", how="left")
    df["usd_value"] = df["eth_value"] * df["TX_ETH_USD_price"]

    return df

df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'].unique()})
from tqdm import tqdm
for tx_hash in tqdm(df_hashes["hash"].unique(), desc="Processing tx hashes"):

df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head()

from web3 import Web3
from decimal import Decimal
import pandas as pd

# Global cache dictionary: {(symbol, block_number): price}
CHAINLINK_PRICE_CACHE = {}

def get_chainlink_price_at_block(w3, symbol: str, block_number: int) -> Decimal:
    """
    Fetches the USD price of a token (ETH, USDC, etc.) at a specific block using Chainlink.
    Caches prices to reduce repeated calls.
    """
    symbol = symbol.upper()
    key = (symbol, block_number)
    if key in CHAINLINK_PRICE_CACHE:
        return CHAINLINK_PRICE_CACHE[key]

    if symbol not in CHAINLINK_AGGREGATORS:
        raise ValueError(f"No Chainlink feed configured for {symbol}")

    agg_addr = CHAINLINK_AGGREGATORS[symbol]
    contract = w3.eth.contract(address=agg_addr, abi=CHAINLINK_ABI)

    # Get target timestamp for the block
    try:
        target_ts = w3.eth.get_block(block_number)["timestamp"]
    except:
        return Decimal("0")

    # Binary search for closest round <= timestamp
    latest_round = contract.functions.latestRoundData().call()[0]
    low, high = 1, latest_round
    closest_price = None

    while low <= high:
        mid = (low + high) // 2
        try:
            rd = contract.functions.getRoundData(mid).call()
            updated_at = rd[3]
            price = rd[1]

            if updated_at <= target_ts:
                closest_price = Decimal(price) / Decimal(1e8)
                low = mid + 1
            else:
                high = mid - 1
        except:
            high = mid - 1  # Skip bad rounds

    if closest_price is not None:
        CHAINLINK_PRICE_CACHE[key] = closest_price
        return closest_price

    # fallback
    return Decimal("0")

def prewarm_chainlink_cache(w3, block_numbers: list, symbols: list):
    """
    Preloads Chainlink prices for given block numbers and symbols into the global cache.
    """
    from tqdm import tqdm
    symbols = [s.upper() for s in symbols]
    print(f"🔄 Prewarming Chainlink cache for {len(symbols)} symbols × {len(block_numbers)} blocks...")

    for symbol in tqdm(symbols, desc="Symbols"):
        for blk in tqdm(block_numbers, leave=False, desc=f"{symbol} blocks"):
            try:
                get_chainlink_price_at_block(w3, symbol, blk)
            except Exception as e:
                print(f"⚠️ Failed to cache {symbol} @ block {blk}: {e}")

def get_token_eth_price_at_block(w3, token_symbol, block_number):
    """
    Return token/ETH price at given block.
    For stablecoins, price is $1 / ETH price from Chainlink.
    """
    STABLECOINS = {"USDC", "USDT", "DAI"}
    token_symbol = token_symbol.upper()

    if token_symbol == "ETH":
        return Decimal("1.0")

    if token_symbol in STABLECOINS:
        eth_usd = get_chainlink_price_at_block(w3, "ETH", block_number)
        return Decimal("1.0") / eth_usd if eth_usd else Decimal("0")

    # Optionally: fallback to 0 for unsupported tokens (or extend with Reservoir)
    return Decimal("0")


# Chainlink Aggregator ABI (minimal)
CHAINLINK_AGGREGATOR_ABI = [
    {
        "inputs": [{"internalType": "uint80", "name": "_roundId", "type": "uint80"}],
        "name": "getRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"},
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "latestRoundData",
        "outputs": [
            {"name": "roundId", "type": "uint80"},
            {"name": "answer", "type": "int256"},
            {"name": "startedAt", "type": "uint256"},
            {"name": "updatedAt", "type": "uint256"},
            {"name": "answeredInRound", "type": "uint80"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

# Uniswap V3 Pool ABI (minimal)
UNISWAP_V3_POOL_ABI = [
    {
        "inputs": [{"internalType": "uint32[]", "name": "secondsAgos", "type": "uint32[]"}],
        "name": "observe",
        "outputs": [
            {"internalType": "int56[]", "name": "tickCumulatives", "type": "int56[]"},
            {"internalType": "uint160[]", "name": "secondsPerLiquidityCumulativeX128s", "type": "uint160[]"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {"name": "token0", "outputs": [{"type": "address"}], "stateMutability": "view", "type": "function"},
    {"name": "token1", "outputs": [{"type": "address"}], "stateMutability": "view", "type": "function"},
]

# Feeds and Pools
CHAINLINK_TOKEN_ETH_FEEDS = {
    "USDC": "0x986b5E1e1755e3C2440e960477f25201B0a8bbD4",
    "DAI":  "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9",
    "LINK": "0xb4c4a493AB6356497713A78FFA6c60FB53517c63",
    # Add more
}

UNISWAP_TOKEN_ETH_POOLS = {
    "USDC": "0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640",  # USDC/WETH 0.05%
    "DAI":  "0xC2e9f25be6257c210d7adf0d4cd6e3e881ba25f8",
    "LINK": "0xa2107fa78b2519cbb58c1c3b5f275fe6f45e55dd",
}

df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'].unique()})
from tqdm import tqdm
for tx_hash in tqdm(df_hashes["hash"].unique(), desc="Processing tx hashes"):
  df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head()

def get_block_timestamp(w3, block_number):
    return w3.eth.get_block(block_number)["timestamp"]

def tick_to_price(tick: int) -> Decimal:
    return Decimal(1.0001) ** Decimal(tick)

def get_closest_chainlink_price(w3, aggregator, target_timestamp):
    lower = 1
    upper = aggregator.functions.latestRoundData().call()[0]
    closest = None
    while lower <= upper:
        mid = (lower + upper) // 2
        try:
            _, _, _, updated_at, _ = aggregator.functions.getRoundData(mid).call()
        except:
            break
        if updated_at < target_timestamp:
            lower = mid + 1
        else:
            closest = mid
            upper = mid - 1
    if closest:
        _, answer, _, _, _ = aggregator.functions.getRoundData(closest).call()
        return Decimal(answer) / Decimal(1e18)
    return None

def get_uniswap_twap_token_eth_price(w3, pool_address, seconds_back=600):
    pool = w3.eth.contract(address=Web3.to_checksum_address(pool_address), abi=UNISWAP_V3_POOL_ABI)
    token0 = pool.functions.token0().call()
    token1 = pool.functions.token1().call()
    tick_cumulatives, _ = pool.functions.observe([seconds_back, 0]).call()
    tick_diff = tick_cumulatives[1] - tick_cumulatives[0]
    avg_tick = tick_diff // seconds_back
    price = tick_to_price(avg_tick)
    WETH = "0xC02aaa39b223FE8D0a0e5C4F27eAD9083C756Cc2".lower()
    if token1.lower() == WETH:
        return price  # token/ETH
    else:
        return Decimal(1) / price  # ETH/token ⇒ invert

"""##Final Dataframe"""

df_hashes = pd.DataFrame({'hash': df_for_token_transfers['hash'].unique()})
df_enriched = enrich_token_transfers_from_hashes(df_hashes, w3, aggregator)

df_enriched[
    ["hash", "token_symbol", "from", "to", "token_amount", "eth_value", "usd_value"]
].head()

df_enriched['transfer_type'].unique()

df_enriched["unwrap_detected"] = (
    (df_enriched["transfer_type"] == "eth") &
    (df_enriched["from"].str.lower() == "0xc02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".lower()) &
    (df_enriched["token_symbol"] == "ETH")
)
df_enriched["unwrap_detected"].unique()

df_enriched["token_id"] = np.where(
    df_enriched["token_decimals"].isna(),
    df_enriched["raw_value"],  # retain full-size integer as-is
    pd.NA
)

df_enriched

df_for_token_transfers['tokenSymbol'].unique()

df_for_token_transfers_agg = df_for_token_transfers.groupby('hash').first().reset_index()
df_enriched1 = df_enriched.merge(df_for_token_transfers_agg, on='hash', how='left')
df_enriched1 = df_enriched1[df_enriched1['tokenSymbol'] != "SPX"]
df_enriched1

fund_wallet_ids = [m["wallet_address"].lower() for m in wallet_metadata.values() if m["category"] == "fund"]
fund_wallet_set = set(fund_wallet_ids)  # for faster lookup
df_enriched1['from'] = df_enriched1['from'].str.lower()
df_enriched1['to']   = df_enriched1['to'].str.lower()
df_enriched1 = df_enriched1[
    df_enriched1['from'].isin(fund_wallet_set) | df_enriched1['to'].isin(fund_wallet_set)
].copy()
df_enriched1

df_enriched1["token_id"] = np.where(
    df_enriched1["token_decimals"].isna(),
    df_enriched1["raw_value"],  # retain full-size integer as-is
    pd.NA
)

df_enriched1

df_enriched1['token_decimals'] = pd.to_numeric(df_enriched1['token_decimals'], errors='coerce')
df_enriched1['raw_value'] = pd.to_numeric(df_enriched1['raw_value'], errors='coerce')

STABLECOINS = {"USDC", "USDT", "DAI"}  # expand if needed

def safe_eth_usd_price_and_eth_value(row):
    try:
        # Skip if token_decimals is missing
        if pd.isna(row['token_decimals']):
            return pd.Series([None, row.get('eth_value')])  # Don't change eth_value

        # Compute eth_usd_price
        if pd.isna(row['eth_value']) or row['eth_value'] == 0:
            if row['token_amount'] in [0, None, Decimal(0)]:
                eth_usd_price = None
            else:
                eth_usd_price = row['usd_value'] / row['token_amount']
        else:
            if row['eth_value'] in [0, None, Decimal(0)]:
                eth_usd_price = None
            else:
                eth_usd_price = row['usd_value'] / row['eth_value']

        # Recalculate eth_value for stablecoins if eth_usd_price is available
        eth_value = row.get('eth_value')
        if (
            row.get('tokenSymbol') in STABLECOINS
            and eth_usd_price not in [None, 0, Decimal(0)]
            and row.get('raw_value') not in [None]
        ):
            eth_value = (Decimal(row['raw_value']) / Decimal(10) ** int(row['token_decimals'])) / eth_usd_price

        return pd.Series([eth_usd_price, eth_value])

    except (InvalidOperation, ZeroDivisionError, TypeError, ValueError) as e:
        return pd.Series([None, row.get('eth_value')])

df_enriched1[['eth_usd_price', 'eth_value']] = df_enriched1.apply(safe_eth_usd_price_and_eth_value, axis=1)
df_enriched1
#df_enriched1[df_enriched1['tokenSymbol'] == "MEME"]

def recalculate_usd_value(row):
    try:
        if (
            row['eth_value'] not in [None, Decimal(0)] and
            row['eth_usd_price'] not in [None, Decimal(0)]
        ):
            return row['eth_value'] * row['eth_usd_price']
        return row['usd_value']
    except (InvalidOperation, TypeError):
        return row['usd_value']

df_enriched1['usd_value'] = df_enriched1.apply(recalculate_usd_value, axis=1)

def compute_token_eth_price(row):
    try:
        if (
            row.get("tokenSymbol") in STABLECOINS and
            row.get("eth_usd_price") not in [None, Decimal(0)]
        ):
            return Decimal(1) / row["eth_usd_price"]
        return row.get("token_eth_price")  # preserve existing value if not a stablecoin
    except (InvalidOperation, ZeroDivisionError, TypeError):
        return None

df_enriched1['token_eth_price'] = df_enriched1.apply(compute_token_eth_price, axis=1)


df_enriched1[df_enriched1['tokenSymbol'] == "MEME"]

AIRDROPPED_TOKENS = {"MEME", "ARCD"}

def apply_airdrop_zero_values(row):
    if row.get("tokenSymbol") in AIRDROPPED_TOKENS:
        return pd.Series([Decimal(0), Decimal(0), Decimal(0)])
    return pd.Series([row["usd_value"], row["eth_value"], row["token_eth_price"]])

# Apply after your enrichment step
df_enriched1[["usd_value", "eth_value", "token_eth_price"]] = df_enriched1.apply(apply_airdrop_zero_values, axis=1)
df_enriched1[df_enriched1['tokenSymbol'] == "ARCD"]

df_enriched1[df_enriched1['tokenSymbol'] == "USDC"]

file_name = f"{current_period}_token_activity_detail.csv" #RENAME
df_enriched1.to_csv(f"{path_for_groupings}/{file_name}", index=False)
print(f"File saved at {path_for_groupings}/{file_name}")